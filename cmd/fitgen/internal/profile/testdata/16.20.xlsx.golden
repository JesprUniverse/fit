// TYPES
// This file is auto-generated using the
// program found in 'cmd/fitgen/main.go'
// DO NOT EDIT.
// SDK Version: Unknown

package fit

// ActivityClass represents the activity_class FIT type.
type ActivityClass byte

const (
	ActivityClassLevel    ActivityClass = 0x7F // 0 to 100
	ActivityClassLevelMax ActivityClass = 100
	ActivityClassAthlete  ActivityClass = 0x80
	ActivityClassInvalid  ActivityClass = 0xFF
)

// ActivityLevel represents the activity_level FIT type.
type ActivityLevel byte

const (
	ActivityLevelLow     ActivityLevel = 0
	ActivityLevelMedium  ActivityLevel = 1
	ActivityLevelHigh    ActivityLevel = 2
	ActivityLevelInvalid ActivityLevel = 0xFF
)

// ActivityMode represents the activity FIT type.
type ActivityMode byte

const (
	ActivityModeManual         ActivityMode = 0
	ActivityModeAutoMultiSport ActivityMode = 1
	ActivityModeInvalid        ActivityMode = 0xFF
)

// ActivitySubtype represents the activity_subtype FIT type.
type ActivitySubtype byte

const (
	ActivitySubtypeGeneric       ActivitySubtype = 0
	ActivitySubtypeTreadmill     ActivitySubtype = 1  // Run
	ActivitySubtypeStreet        ActivitySubtype = 2  // Run
	ActivitySubtypeTrail         ActivitySubtype = 3  // Run
	ActivitySubtypeTrack         ActivitySubtype = 4  // Run
	ActivitySubtypeSpin          ActivitySubtype = 5  // Cycling
	ActivitySubtypeIndoorCycling ActivitySubtype = 6  // Cycling
	ActivitySubtypeRoad          ActivitySubtype = 7  // Cycling
	ActivitySubtypeMountain      ActivitySubtype = 8  // Cycling
	ActivitySubtypeDownhill      ActivitySubtype = 9  // Cycling
	ActivitySubtypeRecumbent     ActivitySubtype = 10 // Cycling
	ActivitySubtypeCyclocross    ActivitySubtype = 11 // Cycling
	ActivitySubtypeHandCycling   ActivitySubtype = 12 // Cycling
	ActivitySubtypeTrackCycling  ActivitySubtype = 13 // Cycling
	ActivitySubtypeIndoorRowing  ActivitySubtype = 14 // Fitness Equipment
	ActivitySubtypeElliptical    ActivitySubtype = 15 // Fitness Equipment
	ActivitySubtypeStairClimbing ActivitySubtype = 16 // Fitness Equipment
	ActivitySubtypeLapSwimming   ActivitySubtype = 17 // Swimming
	ActivitySubtypeOpenWater     ActivitySubtype = 18 // Swimming
	ActivitySubtypeAll           ActivitySubtype = 254
	ActivitySubtypeInvalid       ActivitySubtype = 0xFF
)

// ActivityType represents the activity_type FIT type.
type ActivityType byte

const (
	ActivityTypeGeneric          ActivityType = 0
	ActivityTypeRunning          ActivityType = 1
	ActivityTypeCycling          ActivityType = 2
	ActivityTypeTransition       ActivityType = 3 // Mulitsport transition
	ActivityTypeFitnessEquipment ActivityType = 4
	ActivityTypeSwimming         ActivityType = 5
	ActivityTypeWalking          ActivityType = 6
	ActivityTypeAll              ActivityType = 254 // All is for goals only to include all sports.
	ActivityTypeInvalid          ActivityType = 0xFF
)

// AntNetwork represents the ant_network FIT type.
type AntNetwork byte

const (
	AntNetworkPublic  AntNetwork = 0
	AntNetworkAntplus AntNetwork = 1
	AntNetworkAntfs   AntNetwork = 2
	AntNetworkPrivate AntNetwork = 3
	AntNetworkInvalid AntNetwork = 0xFF
)

// AntplusDeviceType represents the antplus_device_type FIT type.
type AntplusDeviceType uint8

const (
	AntplusDeviceTypeAntfs                   AntplusDeviceType = 1
	AntplusDeviceTypeBikePower               AntplusDeviceType = 11
	AntplusDeviceTypeEnvironmentSensorLegacy AntplusDeviceType = 12
	AntplusDeviceTypeMultiSportSpeedDistance AntplusDeviceType = 15
	AntplusDeviceTypeControl                 AntplusDeviceType = 16
	AntplusDeviceTypeFitnessEquipment        AntplusDeviceType = 17
	AntplusDeviceTypeBloodPressure           AntplusDeviceType = 18
	AntplusDeviceTypeGeocacheNode            AntplusDeviceType = 19
	AntplusDeviceTypeLightElectricVehicle    AntplusDeviceType = 20
	AntplusDeviceTypeEnvSensor               AntplusDeviceType = 25
	AntplusDeviceTypeRacquet                 AntplusDeviceType = 26
	AntplusDeviceTypeWeightScale             AntplusDeviceType = 119
	AntplusDeviceTypeHeartRate               AntplusDeviceType = 120
	AntplusDeviceTypeBikeSpeedCadence        AntplusDeviceType = 121
	AntplusDeviceTypeBikeCadence             AntplusDeviceType = 122
	AntplusDeviceTypeBikeSpeed               AntplusDeviceType = 123
	AntplusDeviceTypeStrideSpeedDistance     AntplusDeviceType = 124
	AntplusDeviceTypeInvalid                 AntplusDeviceType = 0xFF
)

// AttitudeStage represents the attitude_stage FIT type.
type AttitudeStage byte

const (
	AttitudeStageFailed   AttitudeStage = 0
	AttitudeStageAligning AttitudeStage = 1
	AttitudeStageDegraded AttitudeStage = 2
	AttitudeStageValid    AttitudeStage = 3
	AttitudeStageInvalid  AttitudeStage = 0xFF
)

// AttitudeValidity represents the attitude_validity FIT type.
type AttitudeValidity uint16

const (
	AttitudeValidityTrackAngleHeadingValid AttitudeValidity = 0x0001
	AttitudeValidityPitchValid             AttitudeValidity = 0x0002
	AttitudeValidityRollValid              AttitudeValidity = 0x0004
	AttitudeValidityLateralBodyAccelValid  AttitudeValidity = 0x0008
	AttitudeValidityNormalBodyAccelValid   AttitudeValidity = 0x0010
	AttitudeValidityTurnRateValid          AttitudeValidity = 0x0020
	AttitudeValidityHwFail                 AttitudeValidity = 0x0040
	AttitudeValidityMagInvalid             AttitudeValidity = 0x0080
	AttitudeValidityNoGps                  AttitudeValidity = 0x0100
	AttitudeValidityGpsInvalid             AttitudeValidity = 0x0200
	AttitudeValiditySolutionCoasting       AttitudeValidity = 0x0400
	AttitudeValidityTrueTrackAngle         AttitudeValidity = 0x0800
	AttitudeValidityMagneticHeading        AttitudeValidity = 0x1000
	AttitudeValidityInvalid                AttitudeValidity = 0xFFFF
)

// AutolapTrigger represents the autolap_trigger FIT type.
type AutolapTrigger byte

const (
	AutolapTriggerTime             AutolapTrigger = 0
	AutolapTriggerDistance         AutolapTrigger = 1
	AutolapTriggerPositionStart    AutolapTrigger = 2
	AutolapTriggerPositionLap      AutolapTrigger = 3
	AutolapTriggerPositionWaypoint AutolapTrigger = 4
	AutolapTriggerPositionMarked   AutolapTrigger = 5
	AutolapTriggerOff              AutolapTrigger = 6
	AutolapTriggerInvalid          AutolapTrigger = 0xFF
)

// BatteryStatus represents the battery_status FIT type.
type BatteryStatus uint8

const (
	BatteryStatusNew      BatteryStatus = 1
	BatteryStatusGood     BatteryStatus = 2
	BatteryStatusOk       BatteryStatus = 3
	BatteryStatusLow      BatteryStatus = 4
	BatteryStatusCritical BatteryStatus = 5
	BatteryStatusUnknown  BatteryStatus = 7
	BatteryStatusInvalid  BatteryStatus = 0xFF
)

// BodyLocation represents the body_location FIT type.
type BodyLocation byte

const (
	BodyLocationLeftLeg               BodyLocation = 0
	BodyLocationLeftCalf              BodyLocation = 1
	BodyLocationLeftShin              BodyLocation = 2
	BodyLocationLeftHamstring         BodyLocation = 3
	BodyLocationLeftQuad              BodyLocation = 4
	BodyLocationLeftGlute             BodyLocation = 5
	BodyLocationRightLeg              BodyLocation = 6
	BodyLocationRightCalf             BodyLocation = 7
	BodyLocationRightShin             BodyLocation = 8
	BodyLocationRightHamstring        BodyLocation = 9
	BodyLocationRightQuad             BodyLocation = 10
	BodyLocationRightGlute            BodyLocation = 11
	BodyLocationTorsoBack             BodyLocation = 12
	BodyLocationLeftLowerBack         BodyLocation = 13
	BodyLocationLeftUpperBack         BodyLocation = 14
	BodyLocationRightLowerBack        BodyLocation = 15
	BodyLocationRightUpperBack        BodyLocation = 16
	BodyLocationTorsoFront            BodyLocation = 17
	BodyLocationLeftAbdomen           BodyLocation = 18
	BodyLocationLeftChest             BodyLocation = 19
	BodyLocationRightAbdomen          BodyLocation = 20
	BodyLocationRightChest            BodyLocation = 21
	BodyLocationLeftArm               BodyLocation = 22
	BodyLocationLeftShoulder          BodyLocation = 23
	BodyLocationLeftBicep             BodyLocation = 24
	BodyLocationLeftTricep            BodyLocation = 25
	BodyLocationLeftBrachioradialis   BodyLocation = 26 // Left anterior forearm
	BodyLocationLeftForearmExtensors  BodyLocation = 27 // Left posterior forearm
	BodyLocationRightArm              BodyLocation = 28
	BodyLocationRightShoulder         BodyLocation = 29
	BodyLocationRightBicep            BodyLocation = 30
	BodyLocationRightTricep           BodyLocation = 31
	BodyLocationRightBrachioradialis  BodyLocation = 32 // Right anterior forearm
	BodyLocationRightForearmExtensors BodyLocation = 33 // Right posterior forearm
	BodyLocationNeck                  BodyLocation = 34
	BodyLocationThroat                BodyLocation = 35
	BodyLocationInvalid               BodyLocation = 0xFF
)

// BpStatus represents the bp_status FIT type.
type BpStatus byte

const (
	BpStatusNoError                 BpStatus = 0
	BpStatusErrorIncompleteData     BpStatus = 1
	BpStatusErrorNoMeasurement      BpStatus = 2
	BpStatusErrorDataOutOfRange     BpStatus = 3
	BpStatusErrorIrregularHeartRate BpStatus = 4
	BpStatusInvalid                 BpStatus = 0xFF
)

// CameraEventType represents the camera_event_type FIT type.
type CameraEventType byte

const (
	CameraEventTypeVideoStart                  CameraEventType = 0 // Start of video recording
	CameraEventTypeVideoSplit                  CameraEventType = 1 // Mark of video file split (end of one file, beginning of the other)
	CameraEventTypeVideoEnd                    CameraEventType = 2 // End of video recording
	CameraEventTypePhotoTaken                  CameraEventType = 3 // Still photo taken
	CameraEventTypeVideoSecondStreamStart      CameraEventType = 4
	CameraEventTypeVideoSecondStreamSplit      CameraEventType = 5
	CameraEventTypeVideoSecondStreamEnd        CameraEventType = 6
	CameraEventTypeVideoSplitStart             CameraEventType = 7 // Mark of video file split start
	CameraEventTypeVideoSecondStreamSplitStart CameraEventType = 8
	CameraEventTypeInvalid                     CameraEventType = 0xFF
)

// CameraOrientationType represents the camera_orientation_type FIT type.
type CameraOrientationType byte

const (
	CameraOrientationTypeCameraOrientation0   CameraOrientationType = 0
	CameraOrientationTypeCameraOrientation90  CameraOrientationType = 1
	CameraOrientationTypeCameraOrientation180 CameraOrientationType = 2
	CameraOrientationTypeCameraOrientation270 CameraOrientationType = 3
	CameraOrientationTypeInvalid              CameraOrientationType = 0xFF
)

// Checksum represents the checksum FIT type.
type Checksum uint8

const (
	ChecksumClear   Checksum = 0 // Allows clear of checksum for flash memory where can only write 1 to 0 without erasing sector.
	ChecksumOk      Checksum = 1 // Set to mark checksum as valid if computes to invalid values 0 or 0xFF.  Checksum can also be set to ok to save encoding computation time.
	ChecksumInvalid Checksum = 0xFF
)

// CommTimeoutType represents the comm_timeout_type FIT type.
type CommTimeoutType uint16

const (
	CommTimeoutTypeWildcardPairingTimeout CommTimeoutType = 0 // Timeout pairing to any device
	CommTimeoutTypePairingTimeout         CommTimeoutType = 1 // Timeout pairing to previously paired device
	CommTimeoutTypeConnectionLost         CommTimeoutType = 2 // Temporary loss of communications
	CommTimeoutTypeConnectionTimeout      CommTimeoutType = 3 // Connection closed due to extended bad communications
	CommTimeoutTypeInvalid                CommTimeoutType = 0xFFFF
)

// ConnectivityCapabilities represents the connectivity_capabilities FIT type.
type ConnectivityCapabilities uint32

const (
	ConnectivityCapabilitiesBluetooth                       ConnectivityCapabilities = 0x00000001
	ConnectivityCapabilitiesBluetoothLe                     ConnectivityCapabilities = 0x00000002
	ConnectivityCapabilitiesAnt                             ConnectivityCapabilities = 0x00000004
	ConnectivityCapabilitiesActivityUpload                  ConnectivityCapabilities = 0x00000008
	ConnectivityCapabilitiesCourseDownload                  ConnectivityCapabilities = 0x00000010
	ConnectivityCapabilitiesWorkoutDownload                 ConnectivityCapabilities = 0x00000020
	ConnectivityCapabilitiesLiveTrack                       ConnectivityCapabilities = 0x00000040
	ConnectivityCapabilitiesWeatherConditions               ConnectivityCapabilities = 0x00000080
	ConnectivityCapabilitiesWeatherAlerts                   ConnectivityCapabilities = 0x00000100
	ConnectivityCapabilitiesGpsEphemerisDownload            ConnectivityCapabilities = 0x00000200
	ConnectivityCapabilitiesExplicitArchive                 ConnectivityCapabilities = 0x00000400
	ConnectivityCapabilitiesSetupIncomplete                 ConnectivityCapabilities = 0x00000800
	ConnectivityCapabilitiesContinueSyncAfterSoftwareUpdate ConnectivityCapabilities = 0x00001000
	ConnectivityCapabilitiesConnectIqAppDownload            ConnectivityCapabilities = 0x00002000
	ConnectivityCapabilitiesInvalid                         ConnectivityCapabilities = 0x00000000
)

// CourseCapabilities represents the course_capabilities FIT type.
type CourseCapabilities uint32

const (
	CourseCapabilitiesProcessed  CourseCapabilities = 0x00000001
	CourseCapabilitiesValid      CourseCapabilities = 0x00000002
	CourseCapabilitiesTime       CourseCapabilities = 0x00000004
	CourseCapabilitiesDistance   CourseCapabilities = 0x00000008
	CourseCapabilitiesPosition   CourseCapabilities = 0x00000010
	CourseCapabilitiesHeartRate  CourseCapabilities = 0x00000020
	CourseCapabilitiesPower      CourseCapabilities = 0x00000040
	CourseCapabilitiesCadence    CourseCapabilities = 0x00000080
	CourseCapabilitiesTraining   CourseCapabilities = 0x00000100
	CourseCapabilitiesNavigation CourseCapabilities = 0x00000200
	CourseCapabilitiesBikeway    CourseCapabilities = 0x00000400
	CourseCapabilitiesInvalid    CourseCapabilities = 0x00000000
)

// CoursePoint represents the course_point FIT type.
type CoursePoint byte

const (
	CoursePointGeneric        CoursePoint = 0
	CoursePointSummit         CoursePoint = 1
	CoursePointValley         CoursePoint = 2
	CoursePointWater          CoursePoint = 3
	CoursePointFood           CoursePoint = 4
	CoursePointDanger         CoursePoint = 5
	CoursePointLeft           CoursePoint = 6
	CoursePointRight          CoursePoint = 7
	CoursePointStraight       CoursePoint = 8
	CoursePointFirstAid       CoursePoint = 9
	CoursePointFourthCategory CoursePoint = 10
	CoursePointThirdCategory  CoursePoint = 11
	CoursePointSecondCategory CoursePoint = 12
	CoursePointFirstCategory  CoursePoint = 13
	CoursePointHorsCategory   CoursePoint = 14
	CoursePointSprint         CoursePoint = 15
	CoursePointLeftFork       CoursePoint = 16
	CoursePointRightFork      CoursePoint = 17
	CoursePointMiddleFork     CoursePoint = 18
	CoursePointSlightLeft     CoursePoint = 19
	CoursePointSharpLeft      CoursePoint = 20
	CoursePointSlightRight    CoursePoint = 21
	CoursePointSharpRight     CoursePoint = 22
	CoursePointUTurn          CoursePoint = 23
	CoursePointInvalid        CoursePoint = 0xFF
)

// DeviceIndex represents the device_index FIT type.
type DeviceIndex uint8

const (
	DeviceIndexCreator DeviceIndex = 0 // Creator of the file is always device index 0.
	DeviceIndexInvalid DeviceIndex = 0xFF
)

// DisplayHeart represents the display_heart FIT type.
type DisplayHeart byte

const (
	DisplayHeartBpm     DisplayHeart = 0
	DisplayHeartMax     DisplayHeart = 1
	DisplayHeartReserve DisplayHeart = 2
	DisplayHeartInvalid DisplayHeart = 0xFF
)

// DisplayMeasure represents the display_measure FIT type.
type DisplayMeasure byte

const (
	DisplayMeasureMetric  DisplayMeasure = 0
	DisplayMeasureStatute DisplayMeasure = 1
	DisplayMeasureInvalid DisplayMeasure = 0xFF
)

// DisplayPosition represents the display_position FIT type.
type DisplayPosition byte

const (
	DisplayPositionDegree               DisplayPosition = 0  // dd.dddddd
	DisplayPositionDegreeMinute         DisplayPosition = 1  // dddmm.mmm
	DisplayPositionDegreeMinuteSecond   DisplayPosition = 2  // dddmmss
	DisplayPositionAustrianGrid         DisplayPosition = 3  // Austrian Grid (BMN)
	DisplayPositionBritishGrid          DisplayPosition = 4  // British National Grid
	DisplayPositionDutchGrid            DisplayPosition = 5  // Dutch grid system
	DisplayPositionHungarianGrid        DisplayPosition = 6  // Hungarian grid system
	DisplayPositionFinnishGrid          DisplayPosition = 7  // Finnish grid system Zone3 KKJ27
	DisplayPositionGermanGrid           DisplayPosition = 8  // Gausss Krueger (German)
	DisplayPositionIcelandicGrid        DisplayPosition = 9  // Icelandic Grid
	DisplayPositionIndonesianEquatorial DisplayPosition = 10 // Indonesian Equatorial LCO
	DisplayPositionIndonesianIrian      DisplayPosition = 11 // Indonesian Irian LCO
	DisplayPositionIndonesianSouthern   DisplayPosition = 12 // Indonesian Southern LCO
	DisplayPositionIndiaZone0           DisplayPosition = 13 // India zone 0
	DisplayPositionIndiaZoneIA          DisplayPosition = 14 // India zone IA
	DisplayPositionIndiaZoneIB          DisplayPosition = 15 // India zone IB
	DisplayPositionIndiaZoneIIA         DisplayPosition = 16 // India zone IIA
	DisplayPositionIndiaZoneIIB         DisplayPosition = 17 // India zone IIB
	DisplayPositionIndiaZoneIIIA        DisplayPosition = 18 // India zone IIIA
	DisplayPositionIndiaZoneIIIB        DisplayPosition = 19 // India zone IIIB
	DisplayPositionIndiaZoneIVA         DisplayPosition = 20 // India zone IVA
	DisplayPositionIndiaZoneIVB         DisplayPosition = 21 // India zone IVB
	DisplayPositionIrishTransverse      DisplayPosition = 22 // Irish Transverse Mercator
	DisplayPositionIrishGrid            DisplayPosition = 23 // Irish Grid
	DisplayPositionLoran                DisplayPosition = 24 // Loran TD
	DisplayPositionMaidenheadGrid       DisplayPosition = 25 // Maidenhead grid system
	DisplayPositionMgrsGrid             DisplayPosition = 26 // MGRS grid system
	DisplayPositionNewZealandGrid       DisplayPosition = 27 // New Zealand grid system
	DisplayPositionNewZealandTransverse DisplayPosition = 28 // New Zealand Transverse Mercator
	DisplayPositionQatarGrid            DisplayPosition = 29 // Qatar National Grid
	DisplayPositionModifiedSwedishGrid  DisplayPosition = 30 // Modified RT-90 (Sweden)
	DisplayPositionSwedishGrid          DisplayPosition = 31 // RT-90 (Sweden)
	DisplayPositionSouthAfricanGrid     DisplayPosition = 32 // South African Grid
	DisplayPositionSwissGrid            DisplayPosition = 33 // Swiss CH-1903 grid
	DisplayPositionTaiwanGrid           DisplayPosition = 34 // Taiwan Grid
	DisplayPositionUnitedStatesGrid     DisplayPosition = 35 // United States National Grid
	DisplayPositionUtmUpsGrid           DisplayPosition = 36 // UTM/UPS grid system
	DisplayPositionWestMalayan          DisplayPosition = 37 // West Malayan RSO
	DisplayPositionBorneoRso            DisplayPosition = 38 // Borneo RSO
	DisplayPositionEstonianGrid         DisplayPosition = 39 // Estonian grid system
	DisplayPositionLatvianGrid          DisplayPosition = 40 // Latvian Transverse Mercator
	DisplayPositionSwedishRef99Grid     DisplayPosition = 41 // Reference Grid 99 TM (Swedish)
	DisplayPositionInvalid              DisplayPosition = 0xFF
)

// DisplayPower represents the display_power FIT type.
type DisplayPower byte

const (
	DisplayPowerWatts      DisplayPower = 0
	DisplayPowerPercentFtp DisplayPower = 1
	DisplayPowerInvalid    DisplayPower = 0xFF
)

// Event represents the event FIT type.
type Event byte

const (
	EventTimer                 Event = 0  // Group 0.  Start / stop_all
	EventWorkout               Event = 3  // start / stop
	EventWorkoutStep           Event = 4  // Start at beginning of workout.  Stop at end of each step.
	EventPowerDown             Event = 5  // stop_all group 0
	EventPowerUp               Event = 6  // stop_all group 0
	EventOffCourse             Event = 7  // start / stop group 0
	EventSession               Event = 8  // Stop at end of each session.
	EventLap                   Event = 9  // Stop at end of each lap.
	EventCoursePoint           Event = 10 // marker
	EventBattery               Event = 11 // marker
	EventVirtualPartnerPace    Event = 12 // Group 1. Start at beginning of activity if VP enabled, when VP pace is changed during activity or VP enabled mid activity.  stop_disable when VP disabled.
	EventHrHighAlert           Event = 13 // Group 0.  Start / stop when in alert condition.
	EventHrLowAlert            Event = 14 // Group 0.  Start / stop when in alert condition.
	EventSpeedHighAlert        Event = 15 // Group 0.  Start / stop when in alert condition.
	EventSpeedLowAlert         Event = 16 // Group 0.  Start / stop when in alert condition.
	EventCadHighAlert          Event = 17 // Group 0.  Start / stop when in alert condition.
	EventCadLowAlert           Event = 18 // Group 0.  Start / stop when in alert condition.
	EventPowerHighAlert        Event = 19 // Group 0.  Start / stop when in alert condition.
	EventPowerLowAlert         Event = 20 // Group 0.  Start / stop when in alert condition.
	EventRecoveryHr            Event = 21 // marker
	EventBatteryLow            Event = 22 // marker
	EventTimeDurationAlert     Event = 23 // Group 1.  Start if enabled mid activity (not required at start of activity). Stop when duration is reached.  stop_disable if disabled.
	EventDistanceDurationAlert Event = 24 // Group 1.  Start if enabled mid activity (not required at start of activity). Stop when duration is reached.  stop_disable if disabled.
	EventCalorieDurationAlert  Event = 25 // Group 1.  Start if enabled mid activity (not required at start of activity). Stop when duration is reached.  stop_disable if disabled.
	EventActivity              Event = 26 // Group 1..  Stop at end of activity.
	EventFitnessEquipment      Event = 27 // marker
	EventLength                Event = 28 // Stop at end of each length.
	EventUserMarker            Event = 32 // marker
	EventSportPoint            Event = 33 // marker
	EventCalibration           Event = 36 // start/stop/marker
	EventFrontGearChange       Event = 42 // marker
	EventRearGearChange        Event = 43 // marker
	EventRiderPositionChange   Event = 44 // marker
	EventElevHighAlert         Event = 45 // Group 0.  Start / stop when in alert condition.
	EventElevLowAlert          Event = 46 // Group 0.  Start / stop when in alert condition.
	EventCommTimeout           Event = 47 // marker
	EventInvalid               Event = 0xFF
)

// EventType represents the event_type FIT type.
type EventType byte

const (
	EventTypeStart                  EventType = 0
	EventTypeStop                   EventType = 1
	EventTypeConsecutiveDepreciated EventType = 2
	EventTypeMarker                 EventType = 3
	EventTypeStopAll                EventType = 4
	EventTypeBeginDepreciated       EventType = 5
	EventTypeEndDepreciated         EventType = 6
	EventTypeEndAllDepreciated      EventType = 7
	EventTypeStopDisable            EventType = 8
	EventTypeStopDisableAll         EventType = 9
	EventTypeInvalid                EventType = 0xFF
)

// File represents the file FIT type.
type File byte

const (
	FileDevice          File = 1  // Read only, single file. Must be in root directory.
	FileSettings        File = 2  // Read/write, single file. Directory=Settings
	FileSport           File = 3  // Read/write, multiple files, file number = sport type. Directory=Sports
	FileActivity        File = 4  // Read/erase, multiple files. Directory=Activities
	FileWorkout         File = 5  // Read/write/erase, multiple files. Directory=Workouts
	FileCourse          File = 6  // Read/write/erase, multiple files. Directory=Courses
	FileSchedules       File = 7  // Read/write, single file. Directory=Schedules
	FileWeight          File = 9  // Read only, single file. Circular buffer. All message definitions at start of file. Directory=Weight
	FileTotals          File = 10 // Read only, single file. Directory=Totals
	FileGoals           File = 11 // Read/write, single file. Directory=Goals
	FileBloodPressure   File = 14 // Read only. Directory=Blood Pressure
	FileMonitoringA     File = 15 // Read only. Directory=Monitoring. File number=sub type.
	FileActivitySummary File = 20 // Read/erase, multiple files. Directory=Activities
	FileMonitoringDaily File = 28
	FileMonitoringB     File = 32   // Read only. Directory=Monitoring. File number=identifier
	FileSegment         File = 34   // Read/write/erase. Multiple Files.  Directory=Segments
	FileSegmentList     File = 35   // Read/write/erase. Single File.  Directory=Segments
	FileMfgRangeMin     File = 0xF7 // 0xF7 - 0xFE reserved for manufacturer specific file types
	FileMfgRangeMax     File = 0xFE // 0xF7 - 0xFE reserved for manufacturer specific file types
	FileInvalid         File = 0xFF
)

// FileFlags represents the file_flags FIT type.
type FileFlags uint8

const (
	FileFlagsRead    FileFlags = 0x02
	FileFlagsWrite   FileFlags = 0x04
	FileFlagsErase   FileFlags = 0x08
	FileFlagsInvalid FileFlags = 0x00
)

// FitnessEquipmentState represents the fitness_equipment_state FIT type.
type FitnessEquipmentState byte

const (
	FitnessEquipmentStateReady   FitnessEquipmentState = 0
	FitnessEquipmentStateInUse   FitnessEquipmentState = 1
	FitnessEquipmentStatePaused  FitnessEquipmentState = 2
	FitnessEquipmentStateUnknown FitnessEquipmentState = 3 // lost connection to fitness equipment
	FitnessEquipmentStateInvalid FitnessEquipmentState = 0xFF
)

// GarminProduct represents the garmin_product FIT type.
type GarminProduct uint16

const (
	GarminProductHrm1                      GarminProduct = 1
	GarminProductAxh01                     GarminProduct = 2 // AXH01 HRM chipset
	GarminProductAxb01                     GarminProduct = 3
	GarminProductAxb02                     GarminProduct = 4
	GarminProductHrm2ss                    GarminProduct = 5
	GarminProductDsiAlf02                  GarminProduct = 6
	GarminProductHrm3ss                    GarminProduct = 7
	GarminProductHrmRunSingleByteProductId GarminProduct = 8  // hrm_run model for HRM ANT+ messaging
	GarminProductBsm                       GarminProduct = 9  // BSM model for ANT+ messaging
	GarminProductBcm                       GarminProduct = 10 // BCM model for ANT+ messaging
	GarminProductAxs01                     GarminProduct = 11 // AXS01 HRM Bike Chipset model for ANT+ messaging
	GarminProductHrmTriSingleByteProductId GarminProduct = 12 // hrm_tri model for HRM ANT+ messaging
	GarminProductFr225SingleByteProductId  GarminProduct = 14 // fr225 model for HRM ANT+ messaging
	GarminProductFr301China                GarminProduct = 473
	GarminProductFr301Japan                GarminProduct = 474
	GarminProductFr301Korea                GarminProduct = 475
	GarminProductFr301Taiwan               GarminProduct = 494
	GarminProductFr405                     GarminProduct = 717 // Forerunner 405
	GarminProductFr50                      GarminProduct = 782 // Forerunner 50
	GarminProductFr405Japan                GarminProduct = 987
	GarminProductFr60                      GarminProduct = 988 // Forerunner 60
	GarminProductDsiAlf01                  GarminProduct = 1011
	GarminProductFr310xt                   GarminProduct = 1018 // Forerunner 310
	GarminProductEdge500                   GarminProduct = 1036
	GarminProductFr110                     GarminProduct = 1124 // Forerunner 110
	GarminProductEdge800                   GarminProduct = 1169
	GarminProductEdge500Taiwan             GarminProduct = 1199
	GarminProductEdge500Japan              GarminProduct = 1213
	GarminProductChirp                     GarminProduct = 1253
	GarminProductFr110Japan                GarminProduct = 1274
	GarminProductEdge200                   GarminProduct = 1325
	GarminProductFr910xt                   GarminProduct = 1328
	GarminProductEdge800Taiwan             GarminProduct = 1333
	GarminProductEdge800Japan              GarminProduct = 1334
	GarminProductAlf04                     GarminProduct = 1341
	GarminProductFr610                     GarminProduct = 1345
	GarminProductFr210Japan                GarminProduct = 1360
	GarminProductVectorSs                  GarminProduct = 1380
	GarminProductVectorCp                  GarminProduct = 1381
	GarminProductEdge800China              GarminProduct = 1386
	GarminProductEdge500China              GarminProduct = 1387
	GarminProductFr610Japan                GarminProduct = 1410
	GarminProductEdge500Korea              GarminProduct = 1422
	GarminProductFr70                      GarminProduct = 1436
	GarminProductFr310xt4t                 GarminProduct = 1446
	GarminProductAmx                       GarminProduct = 1461
	GarminProductFr10                      GarminProduct = 1482
	GarminProductEdge800Korea              GarminProduct = 1497
	GarminProductSwim                      GarminProduct = 1499
	GarminProductFr910xtChina              GarminProduct = 1537
	GarminProductFenix                     GarminProduct = 1551
	GarminProductEdge200Taiwan             GarminProduct = 1555
	GarminProductEdge510                   GarminProduct = 1561
	GarminProductEdge810                   GarminProduct = 1567
	GarminProductTempe                     GarminProduct = 1570
	GarminProductFr910xtJapan              GarminProduct = 1600
	GarminProductFr620                     GarminProduct = 1623
	GarminProductFr220                     GarminProduct = 1632
	GarminProductFr910xtKorea              GarminProduct = 1664
	GarminProductFr10Japan                 GarminProduct = 1688
	GarminProductEdge810Japan              GarminProduct = 1721
	GarminProductVirbElite                 GarminProduct = 1735
	GarminProductEdgeTouring               GarminProduct = 1736 // Also Edge Touring Plus
	GarminProductEdge510Japan              GarminProduct = 1742
	GarminProductHrmTri                    GarminProduct = 1743
	GarminProductHrmRun                    GarminProduct = 1752
	GarminProductFr920xt                   GarminProduct = 1765
	GarminProductEdge510Asia               GarminProduct = 1821
	GarminProductEdge810China              GarminProduct = 1822
	GarminProductEdge810Taiwan             GarminProduct = 1823
	GarminProductEdge1000                  GarminProduct = 1836
	GarminProductVivoFit                   GarminProduct = 1837
	GarminProductVirbRemote                GarminProduct = 1853
	GarminProductVivoKi                    GarminProduct = 1885
	GarminProductFr15                      GarminProduct = 1903
	GarminProductVivoActive                GarminProduct = 1907
	GarminProductEdge510Korea              GarminProduct = 1918
	GarminProductFr620Japan                GarminProduct = 1928
	GarminProductFr620China                GarminProduct = 1929
	GarminProductFr220Japan                GarminProduct = 1930
	GarminProductFr220China                GarminProduct = 1931
	GarminProductApproachS6                GarminProduct = 1936
	GarminProductVivoSmart                 GarminProduct = 1956
	GarminProductFenix2                    GarminProduct = 1967
	GarminProductEpix                      GarminProduct = 1988
	GarminProductFenix3                    GarminProduct = 2050
	GarminProductEdge1000Taiwan            GarminProduct = 2052
	GarminProductEdge1000Japan             GarminProduct = 2053
	GarminProductFr15Japan                 GarminProduct = 2061
	GarminProductEdge520                   GarminProduct = 2067
	GarminProductEdge1000China             GarminProduct = 2070
	GarminProductFr620Russia               GarminProduct = 2072
	GarminProductFr220Russia               GarminProduct = 2073
	GarminProductVectorS                   GarminProduct = 2079
	GarminProductEdge1000Korea             GarminProduct = 2100
	GarminProductFr920xtTaiwan             GarminProduct = 2130
	GarminProductFr920xtChina              GarminProduct = 2131
	GarminProductFr920xtJapan              GarminProduct = 2132
	GarminProductVirbx                     GarminProduct = 2134
	GarminProductVivoSmartApac             GarminProduct = 2135
	GarminProductEtrexTouch                GarminProduct = 2140
	GarminProductEdge25                    GarminProduct = 2147
	GarminProductVivoFit2                  GarminProduct = 2150
	GarminProductFr225                     GarminProduct = 2153
	GarminProductVivoActiveApac            GarminProduct = 2160
	GarminProductVector2                   GarminProduct = 2161
	GarminProductVector2s                  GarminProduct = 2162
	GarminProductVirbxe                    GarminProduct = 2172
	GarminProductFr620Taiwan               GarminProduct = 2173
	GarminProductFr220Taiwan               GarminProduct = 2174
	GarminProductFenix3China               GarminProduct = 2188
	GarminProductFenix3Twn                 GarminProduct = 2189
	GarminProductVariaHeadlight            GarminProduct = 2192
	GarminProductVariaTaillightOld         GarminProduct = 2193
	GarminProductFr225Asia                 GarminProduct = 2219
	GarminProductVariaRadarTaillight       GarminProduct = 2225
	GarminProductVariaRadarDisplay         GarminProduct = 2226
	GarminProductEdge20                    GarminProduct = 2238
	GarminProductD2Bravo                   GarminProduct = 2262
	GarminProductVariaRemote               GarminProduct = 2276
	GarminProductSdm4                      GarminProduct = 10007 // SDM4 footpod
	GarminProductEdgeRemote                GarminProduct = 10014
	GarminProductTrainingCenter            GarminProduct = 20119
	GarminProductAndroidAntplusPlugin      GarminProduct = 65532
	GarminProductConnect                   GarminProduct = 65534 // Garmin Connect website
	GarminProductInvalid                   GarminProduct = 0xFFFF
)

// Gender represents the gender FIT type.
type Gender byte

const (
	GenderFemale  Gender = 0
	GenderMale    Gender = 1
	GenderInvalid Gender = 0xFF
)

// Goal represents the goal FIT type.
type Goal byte

const (
	GoalTime      Goal = 0
	GoalDistance  Goal = 1
	GoalCalories  Goal = 2
	GoalFrequency Goal = 3
	GoalSteps     Goal = 4
	GoalInvalid   Goal = 0xFF
)

// GoalRecurrence represents the goal_recurrence FIT type.
type GoalRecurrence byte

const (
	GoalRecurrenceOff     GoalRecurrence = 0
	GoalRecurrenceDaily   GoalRecurrence = 1
	GoalRecurrenceWeekly  GoalRecurrence = 2
	GoalRecurrenceMonthly GoalRecurrence = 3
	GoalRecurrenceYearly  GoalRecurrence = 4
	GoalRecurrenceCustom  GoalRecurrence = 5
	GoalRecurrenceInvalid GoalRecurrence = 0xFF
)

// HrType represents the hr_type FIT type.
type HrType byte

const (
	HrTypeNormal    HrType = 0
	HrTypeIrregular HrType = 1
	HrTypeInvalid   HrType = 0xFF
)

// HrZoneCalc represents the hr_zone_calc FIT type.
type HrZoneCalc byte

const (
	HrZoneCalcCustom       HrZoneCalc = 0
	HrZoneCalcPercentMaxHr HrZoneCalc = 1
	HrZoneCalcPercentHrr   HrZoneCalc = 2
	HrZoneCalcInvalid      HrZoneCalc = 0xFF
)

// Intensity represents the intensity FIT type.
type Intensity byte

const (
	IntensityActive   Intensity = 0
	IntensityRest     Intensity = 1
	IntensityWarmup   Intensity = 2
	IntensityCooldown Intensity = 3
	IntensityInvalid  Intensity = 0xFF
)

// Language represents the language FIT type.
type Language byte

const (
	LanguageEnglish    Language = 0
	LanguageFrench     Language = 1
	LanguageItalian    Language = 2
	LanguageGerman     Language = 3
	LanguageSpanish    Language = 4
	LanguageCroatian   Language = 5
	LanguageCzech      Language = 6
	LanguageDanish     Language = 7
	LanguageDutch      Language = 8
	LanguageFinnish    Language = 9
	LanguageGreek      Language = 10
	LanguageHungarian  Language = 11
	LanguageNorwegian  Language = 12
	LanguagePolish     Language = 13
	LanguagePortuguese Language = 14
	LanguageSlovakian  Language = 15
	LanguageSlovenian  Language = 16
	LanguageSwedish    Language = 17
	LanguageRussian    Language = 18
	LanguageTurkish    Language = 19
	LanguageLatvian    Language = 20
	LanguageUkrainian  Language = 21
	LanguageArabic     Language = 22
	LanguageFarsi      Language = 23
	LanguageBulgarian  Language = 24
	LanguageRomanian   Language = 25
	LanguageCustom     Language = 254
	LanguageInvalid    Language = 0xFF
)

// LapTrigger represents the lap_trigger FIT type.
type LapTrigger byte

const (
	LapTriggerManual           LapTrigger = 0
	LapTriggerTime             LapTrigger = 1
	LapTriggerDistance         LapTrigger = 2
	LapTriggerPositionStart    LapTrigger = 3
	LapTriggerPositionLap      LapTrigger = 4
	LapTriggerPositionWaypoint LapTrigger = 5
	LapTriggerPositionMarked   LapTrigger = 6
	LapTriggerSessionEnd       LapTrigger = 7
	LapTriggerFitnessEquipment LapTrigger = 8
	LapTriggerInvalid          LapTrigger = 0xFF
)

// LeftRightBalance represents the left_right_balance FIT type.
type LeftRightBalance uint8

const (
	LeftRightBalanceMask    LeftRightBalance = 0x7F // % contribution
	LeftRightBalanceRight   LeftRightBalance = 0x80 // data corresponds to right if set, otherwise unknown
	LeftRightBalanceInvalid LeftRightBalance = 0xFF
)

// LeftRightBalance100 represents the left_right_balance_100 FIT type.
type LeftRightBalance100 uint16

const (
	LeftRightBalance100Mask    LeftRightBalance100 = 0x3FFF // % contribution scaled by 100
	LeftRightBalance100Right   LeftRightBalance100 = 0x8000 // data corresponds to right if set, otherwise unknown
	LeftRightBalance100Invalid LeftRightBalance100 = 0xFFFF
)

// LengthType represents the length_type FIT type.
type LengthType byte

const (
	LengthTypeIdle    LengthType = 0 // Rest period. Length with no strokes
	LengthTypeActive  LengthType = 1 // Length with strokes.
	LengthTypeInvalid LengthType = 0xFF
)

// Manufacturer represents the manufacturer FIT type.
type Manufacturer uint16

const (
	ManufacturerGarmin                 Manufacturer = 1
	ManufacturerGarminFr405Antfs       Manufacturer = 2 // Do not use.  Used by FR405 for ANTFS man id.
	ManufacturerZephyr                 Manufacturer = 3
	ManufacturerDayton                 Manufacturer = 4
	ManufacturerIdt                    Manufacturer = 5
	ManufacturerSrm                    Manufacturer = 6
	ManufacturerQuarq                  Manufacturer = 7
	ManufacturerIbike                  Manufacturer = 8
	ManufacturerSaris                  Manufacturer = 9
	ManufacturerSparkHk                Manufacturer = 10
	ManufacturerTanita                 Manufacturer = 11
	ManufacturerEchowell               Manufacturer = 12
	ManufacturerDynastreamOem          Manufacturer = 13
	ManufacturerNautilus               Manufacturer = 14
	ManufacturerDynastream             Manufacturer = 15
	ManufacturerTimex                  Manufacturer = 16
	ManufacturerMetrigear              Manufacturer = 17
	ManufacturerXelic                  Manufacturer = 18
	ManufacturerBeurer                 Manufacturer = 19
	ManufacturerCardiosport            Manufacturer = 20
	ManufacturerAAndD                  Manufacturer = 21
	ManufacturerHmm                    Manufacturer = 22
	ManufacturerSuunto                 Manufacturer = 23
	ManufacturerThitaElektronik        Manufacturer = 24
	ManufacturerGpulse                 Manufacturer = 25
	ManufacturerCleanMobile            Manufacturer = 26
	ManufacturerPedalBrain             Manufacturer = 27
	ManufacturerPeaksware              Manufacturer = 28
	ManufacturerSaxonar                Manufacturer = 29
	ManufacturerLemondFitness          Manufacturer = 30
	ManufacturerDexcom                 Manufacturer = 31
	ManufacturerWahooFitness           Manufacturer = 32
	ManufacturerOctaneFitness          Manufacturer = 33
	ManufacturerArchinoetics           Manufacturer = 34
	ManufacturerTheHurtBox             Manufacturer = 35
	ManufacturerCitizenSystems         Manufacturer = 36
	ManufacturerMagellan               Manufacturer = 37
	ManufacturerOsynce                 Manufacturer = 38
	ManufacturerHolux                  Manufacturer = 39
	ManufacturerConcept2               Manufacturer = 40
	ManufacturerOneGiantLeap           Manufacturer = 42
	ManufacturerAceSensor              Manufacturer = 43
	ManufacturerBrimBrothers           Manufacturer = 44
	ManufacturerXplova                 Manufacturer = 45
	ManufacturerPerceptionDigital      Manufacturer = 46
	ManufacturerBf1systems             Manufacturer = 47
	ManufacturerPioneer                Manufacturer = 48
	ManufacturerSpantec                Manufacturer = 49
	ManufacturerMetalogics             Manufacturer = 50
	Manufacturer4iiiis                 Manufacturer = 51
	ManufacturerSeikoEpson             Manufacturer = 52
	ManufacturerSeikoEpsonOem          Manufacturer = 53
	ManufacturerIforPowell             Manufacturer = 54
	ManufacturerMaxwellGuider          Manufacturer = 55
	ManufacturerStarTrac               Manufacturer = 56
	ManufacturerBreakaway              Manufacturer = 57
	ManufacturerAlatechTechnologyLtd   Manufacturer = 58
	ManufacturerMioTechnologyEurope    Manufacturer = 59
	ManufacturerRotor                  Manufacturer = 60
	ManufacturerGeonaute               Manufacturer = 61
	ManufacturerIdBike                 Manufacturer = 62
	ManufacturerSpecialized            Manufacturer = 63
	ManufacturerWtek                   Manufacturer = 64
	ManufacturerPhysicalEnterprises    Manufacturer = 65
	ManufacturerNorthPoleEngineering   Manufacturer = 66
	ManufacturerBkool                  Manufacturer = 67
	ManufacturerCateye                 Manufacturer = 68
	ManufacturerStagesCycling          Manufacturer = 69
	ManufacturerSigmasport             Manufacturer = 70
	ManufacturerTomtom                 Manufacturer = 71
	ManufacturerPeripedal              Manufacturer = 72
	ManufacturerWattbike               Manufacturer = 73
	ManufacturerMoxy                   Manufacturer = 76
	ManufacturerCiclosport             Manufacturer = 77
	ManufacturerPowerbahn              Manufacturer = 78
	ManufacturerAcornProjectsAps       Manufacturer = 79
	ManufacturerLifebeam               Manufacturer = 80
	ManufacturerBontrager              Manufacturer = 81
	ManufacturerWellgo                 Manufacturer = 82
	ManufacturerScosche                Manufacturer = 83
	ManufacturerMagura                 Manufacturer = 84
	ManufacturerWoodway                Manufacturer = 85
	ManufacturerElite                  Manufacturer = 86
	ManufacturerNielsenKellerman       Manufacturer = 87
	ManufacturerDkCity                 Manufacturer = 88
	ManufacturerTacx                   Manufacturer = 89
	ManufacturerDirectionTechnology    Manufacturer = 90
	ManufacturerMagtonic               Manufacturer = 91
	Manufacturer1partcarbon            Manufacturer = 92
	ManufacturerInsideRideTechnologies Manufacturer = 93
	ManufacturerSoundOfMotion          Manufacturer = 94
	ManufacturerStryd                  Manufacturer = 95
	ManufacturerIcg                    Manufacturer = 96 // Indoorcycling Group
	ManufacturerMiPulse                Manufacturer = 97
	ManufacturerBsxAthletics           Manufacturer = 98
	ManufacturerLook                   Manufacturer = 99
	ManufacturerDevelopment            Manufacturer = 255
	ManufacturerHealthandlife          Manufacturer = 257
	ManufacturerLezyne                 Manufacturer = 258
	ManufacturerScribeLabs             Manufacturer = 259
	ManufacturerZwift                  Manufacturer = 260
	ManufacturerWatteam                Manufacturer = 261
	ManufacturerRecon                  Manufacturer = 262
	ManufacturerFaveroElectronics      Manufacturer = 263
	ManufacturerDynovelo               Manufacturer = 264
	ManufacturerStrava                 Manufacturer = 265
	ManufacturerActigraphcorp          Manufacturer = 5759
	ManufacturerInvalid                Manufacturer = 0xFFFF
)

// MesgCount represents the mesg_count FIT type.
type MesgCount byte

const (
	MesgCountNumPerFile     MesgCount = 0
	MesgCountMaxPerFile     MesgCount = 1
	MesgCountMaxPerFileType MesgCount = 2
	MesgCountInvalid        MesgCount = 0xFF
)

// MesgNum represents the mesg_num FIT type.
type MesgNum uint16

const (
	MesgNumFileId                  MesgNum = 0
	MesgNumCapabilities            MesgNum = 1
	MesgNumDeviceSettings          MesgNum = 2
	MesgNumUserProfile             MesgNum = 3
	MesgNumHrmProfile              MesgNum = 4
	MesgNumSdmProfile              MesgNum = 5
	MesgNumBikeProfile             MesgNum = 6
	MesgNumZonesTarget             MesgNum = 7
	MesgNumHrZone                  MesgNum = 8
	MesgNumPowerZone               MesgNum = 9
	MesgNumMetZone                 MesgNum = 10
	MesgNumSport                   MesgNum = 12
	MesgNumGoal                    MesgNum = 15
	MesgNumSession                 MesgNum = 18
	MesgNumLap                     MesgNum = 19
	MesgNumRecord                  MesgNum = 20
	MesgNumEvent                   MesgNum = 21
	MesgNumDeviceInfo              MesgNum = 23
	MesgNumWorkout                 MesgNum = 26
	MesgNumWorkoutStep             MesgNum = 27
	MesgNumSchedule                MesgNum = 28
	MesgNumWeightScale             MesgNum = 30
	MesgNumCourse                  MesgNum = 31
	MesgNumCoursePoint             MesgNum = 32
	MesgNumTotals                  MesgNum = 33
	MesgNumActivity                MesgNum = 34
	MesgNumSoftware                MesgNum = 35
	MesgNumFileCapabilities        MesgNum = 37
	MesgNumMesgCapabilities        MesgNum = 38
	MesgNumFieldCapabilities       MesgNum = 39
	MesgNumFileCreator             MesgNum = 49
	MesgNumBloodPressure           MesgNum = 51
	MesgNumSpeedZone               MesgNum = 53
	MesgNumMonitoring              MesgNum = 55
	MesgNumTrainingFile            MesgNum = 72
	MesgNumHrv                     MesgNum = 78
	MesgNumLength                  MesgNum = 101
	MesgNumMonitoringInfo          MesgNum = 103
	MesgNumPad                     MesgNum = 105
	MesgNumSlaveDevice             MesgNum = 106
	MesgNumCadenceZone             MesgNum = 131
	MesgNumSegmentLap              MesgNum = 142
	MesgNumMemoGlob                MesgNum = 145
	MesgNumSegmentId               MesgNum = 148
	MesgNumSegmentLeaderboardEntry MesgNum = 149
	MesgNumSegmentPoint            MesgNum = 150
	MesgNumSegmentFile             MesgNum = 151
	MesgNumGpsMetadata             MesgNum = 160
	MesgNumCameraEvent             MesgNum = 161
	MesgNumTimestampCorrelation    MesgNum = 162
	MesgNumGyroscopeData           MesgNum = 164
	MesgNumAccelerometerData       MesgNum = 165
	MesgNumThreeDSensorCalibration MesgNum = 167
	MesgNumVideoFrame              MesgNum = 169
	MesgNumObdiiData               MesgNum = 174
	MesgNumNmeaSentence            MesgNum = 177
	MesgNumAviationAttitude        MesgNum = 178
	MesgNumVideo                   MesgNum = 184
	MesgNumVideoTitle              MesgNum = 185
	MesgNumVideoDescription        MesgNum = 186
	MesgNumVideoClip               MesgNum = 187
	MesgNumMfgRangeMin             MesgNum = 0xFF00 // 0xFF00 - 0xFFFE reserved for manufacturer specific messages
	MesgNumMfgRangeMax             MesgNum = 0xFFFE // 0xFF00 - 0xFFFE reserved for manufacturer specific messages
	MesgNumInvalid                 MesgNum = 0xFFFF
)

// MessageIndex represents the message_index FIT type.
type MessageIndex uint16

const (
	MessageIndexSelected MessageIndex = 0x8000 // message is selected if set
	MessageIndexReserved MessageIndex = 0x7000 // reserved (default 0)
	MessageIndexMask     MessageIndex = 0x0FFF // index
	MessageIndexInvalid  MessageIndex = 0xFFFF
)

// PowerPhaseType represents the power_phase_type FIT type.
type PowerPhaseType byte

const (
	PowerPhaseTypePowerPhaseStartAngle PowerPhaseType = 0
	PowerPhaseTypePowerPhaseEndAngle   PowerPhaseType = 1
	PowerPhaseTypePowerPhaseArcLength  PowerPhaseType = 2
	PowerPhaseTypePowerPhaseCenter     PowerPhaseType = 3
	PowerPhaseTypeInvalid              PowerPhaseType = 0xFF
)

// PwrZoneCalc represents the pwr_zone_calc FIT type.
type PwrZoneCalc byte

const (
	PwrZoneCalcCustom     PwrZoneCalc = 0
	PwrZoneCalcPercentFtp PwrZoneCalc = 1
	PwrZoneCalcInvalid    PwrZoneCalc = 0xFF
)

// RiderPositionType represents the rider_position_type FIT type.
type RiderPositionType byte

const (
	RiderPositionTypeSeated   RiderPositionType = 0
	RiderPositionTypeStanding RiderPositionType = 1
	RiderPositionTypeInvalid  RiderPositionType = 0xFF
)

// Schedule represents the schedule FIT type.
type Schedule byte

const (
	ScheduleWorkout Schedule = 0
	ScheduleCourse  Schedule = 1
	ScheduleInvalid Schedule = 0xFF
)

// SegmentDeleteStatus represents the segment_delete_status FIT type.
type SegmentDeleteStatus byte

const (
	SegmentDeleteStatusDoNotDelete SegmentDeleteStatus = 0
	SegmentDeleteStatusDeleteOne   SegmentDeleteStatus = 1
	SegmentDeleteStatusDeleteAll   SegmentDeleteStatus = 2
	SegmentDeleteStatusInvalid     SegmentDeleteStatus = 0xFF
)

// SegmentLapStatus represents the segment_lap_status FIT type.
type SegmentLapStatus byte

const (
	SegmentLapStatusEnd     SegmentLapStatus = 0
	SegmentLapStatusFail    SegmentLapStatus = 1
	SegmentLapStatusInvalid SegmentLapStatus = 0xFF
)

// SegmentLeaderboardType represents the segment_leaderboard_type FIT type.
type SegmentLeaderboardType byte

const (
	SegmentLeaderboardTypeOverall      SegmentLeaderboardType = 0
	SegmentLeaderboardTypePersonalBest SegmentLeaderboardType = 1
	SegmentLeaderboardTypeConnections  SegmentLeaderboardType = 2
	SegmentLeaderboardTypeGroup        SegmentLeaderboardType = 3
	SegmentLeaderboardTypeChallenger   SegmentLeaderboardType = 4
	SegmentLeaderboardTypeKom          SegmentLeaderboardType = 5
	SegmentLeaderboardTypeQom          SegmentLeaderboardType = 6
	SegmentLeaderboardTypePr           SegmentLeaderboardType = 7
	SegmentLeaderboardTypeGoal         SegmentLeaderboardType = 8
	SegmentLeaderboardTypeRival        SegmentLeaderboardType = 9
	SegmentLeaderboardTypeClubLeader   SegmentLeaderboardType = 10
	SegmentLeaderboardTypeInvalid      SegmentLeaderboardType = 0xFF
)

// SegmentSelectionType represents the segment_selection_type FIT type.
type SegmentSelectionType byte

const (
	SegmentSelectionTypeStarred   SegmentSelectionType = 0
	SegmentSelectionTypeSuggested SegmentSelectionType = 1
	SegmentSelectionTypeInvalid   SegmentSelectionType = 0xFF
)

// SensorType represents the sensor_type FIT type.
type SensorType byte

const (
	SensorTypeAccelerometer SensorType = 0
	SensorTypeGyroscope     SensorType = 1
	SensorTypeCompass       SensorType = 2
	SensorTypeInvalid       SensorType = 0xFF
)

// SessionTrigger represents the session_trigger FIT type.
type SessionTrigger byte

const (
	SessionTriggerActivityEnd      SessionTrigger = 0
	SessionTriggerManual           SessionTrigger = 1 // User changed sport.
	SessionTriggerAutoMultiSport   SessionTrigger = 2 // Auto multi-sport feature is enabled and user pressed lap button to advance session.
	SessionTriggerFitnessEquipment SessionTrigger = 3 // Auto sport change caused by user linking to fitness equipment.
	SessionTriggerInvalid          SessionTrigger = 0xFF
)

// SourceType represents the source_type FIT type.
type SourceType byte

const (
	SourceTypeAnt                SourceType = 0 // External device connected with ANT
	SourceTypeAntplus            SourceType = 1 // External device connected with ANT+
	SourceTypeBluetooth          SourceType = 2 // External device connected with BT
	SourceTypeBluetoothLowEnergy SourceType = 3 // External device connected with BLE
	SourceTypeWifi               SourceType = 4 // External device connected with Wifi
	SourceTypeLocal              SourceType = 5 // Onboard device
	SourceTypeInvalid            SourceType = 0xFF
)

// Sport represents the sport FIT type.
type Sport byte

const (
	SportGeneric               Sport = 0
	SportRunning               Sport = 1
	SportCycling               Sport = 2
	SportTransition            Sport = 3 // Mulitsport transition
	SportFitnessEquipment      Sport = 4
	SportSwimming              Sport = 5
	SportBasketball            Sport = 6
	SportSoccer                Sport = 7
	SportTennis                Sport = 8
	SportAmericanFootball      Sport = 9
	SportTraining              Sport = 10
	SportWalking               Sport = 11
	SportCrossCountrySkiing    Sport = 12
	SportAlpineSkiing          Sport = 13
	SportSnowboarding          Sport = 14
	SportRowing                Sport = 15
	SportMountaineering        Sport = 16
	SportHiking                Sport = 17
	SportMultisport            Sport = 18
	SportPaddling              Sport = 19
	SportFlying                Sport = 20
	SportEBiking               Sport = 21
	SportMotorcycling          Sport = 22
	SportBoating               Sport = 23
	SportDriving               Sport = 24
	SportGolf                  Sport = 25
	SportHangGliding           Sport = 26
	SportHorsebackRiding       Sport = 27
	SportHunting               Sport = 28
	SportFishing               Sport = 29
	SportInlineSkating         Sport = 30
	SportRockClimbing          Sport = 31
	SportSailing               Sport = 32
	SportIceSkating            Sport = 33
	SportSkyDiving             Sport = 34
	SportSnowshoeing           Sport = 35
	SportSnowmobiling          Sport = 36
	SportStandUpPaddleboarding Sport = 37
	SportSurfing               Sport = 38
	SportWakeboarding          Sport = 39
	SportWaterSkiing           Sport = 40
	SportKayaking              Sport = 41
	SportRafting               Sport = 42
	SportWindsurfing           Sport = 43
	SportKitesurfing           Sport = 44
	SportAll                   Sport = 254 // All is for goals only to include all sports.
	SportInvalid               Sport = 0xFF
)

// SportBits0 represents the sport_bits_0 FIT type.
type SportBits0 uint8

const (
	SportBits0Generic          SportBits0 = 0x01
	SportBits0Running          SportBits0 = 0x02
	SportBits0Cycling          SportBits0 = 0x04
	SportBits0Transition       SportBits0 = 0x08 // Mulitsport transition
	SportBits0FitnessEquipment SportBits0 = 0x10
	SportBits0Swimming         SportBits0 = 0x20
	SportBits0Basketball       SportBits0 = 0x40
	SportBits0Soccer           SportBits0 = 0x80
	SportBits0Invalid          SportBits0 = 0x00
)

// SportBits1 represents the sport_bits_1 FIT type.
type SportBits1 uint8

const (
	SportBits1Tennis             SportBits1 = 0x01
	SportBits1AmericanFootball   SportBits1 = 0x02
	SportBits1Training           SportBits1 = 0x04
	SportBits1Walking            SportBits1 = 0x08
	SportBits1CrossCountrySkiing SportBits1 = 0x10
	SportBits1AlpineSkiing       SportBits1 = 0x20
	SportBits1Snowboarding       SportBits1 = 0x40
	SportBits1Rowing             SportBits1 = 0x80
	SportBits1Invalid            SportBits1 = 0x00
)

// SportBits2 represents the sport_bits_2 FIT type.
type SportBits2 uint8

const (
	SportBits2Mountaineering SportBits2 = 0x01
	SportBits2Hiking         SportBits2 = 0x02
	SportBits2Multisport     SportBits2 = 0x04
	SportBits2Paddling       SportBits2 = 0x08
	SportBits2Flying         SportBits2 = 0x10
	SportBits2EBiking        SportBits2 = 0x20
	SportBits2Motorcycling   SportBits2 = 0x40
	SportBits2Boating        SportBits2 = 0x80
	SportBits2Invalid        SportBits2 = 0x00
)

// SportBits3 represents the sport_bits_3 FIT type.
type SportBits3 uint8

const (
	SportBits3Driving         SportBits3 = 0x01
	SportBits3Golf            SportBits3 = 0x02
	SportBits3HangGliding     SportBits3 = 0x04
	SportBits3HorsebackRiding SportBits3 = 0x08
	SportBits3Hunting         SportBits3 = 0x10
	SportBits3Fishing         SportBits3 = 0x20
	SportBits3InlineSkating   SportBits3 = 0x40
	SportBits3RockClimbing    SportBits3 = 0x80
	SportBits3Invalid         SportBits3 = 0x00
)

// SportBits4 represents the sport_bits_4 FIT type.
type SportBits4 uint8

const (
	SportBits4Sailing               SportBits4 = 0x01
	SportBits4IceSkating            SportBits4 = 0x02
	SportBits4SkyDiving             SportBits4 = 0x04
	SportBits4Snowshoeing           SportBits4 = 0x08
	SportBits4Snowmobiling          SportBits4 = 0x10
	SportBits4StandUpPaddleboarding SportBits4 = 0x20
	SportBits4Surfing               SportBits4 = 0x40
	SportBits4Wakeboarding          SportBits4 = 0x80
	SportBits4Invalid               SportBits4 = 0x00
)

// SportBits5 represents the sport_bits_5 FIT type.
type SportBits5 uint8

const (
	SportBits5WaterSkiing SportBits5 = 0x01
	SportBits5Kayaking    SportBits5 = 0x02
	SportBits5Rafting     SportBits5 = 0x04
	SportBits5Windsurfing SportBits5 = 0x08
	SportBits5Kitesurfing SportBits5 = 0x10
	SportBits5Invalid     SportBits5 = 0x00
)

// SportEvent represents the sport_event FIT type.
type SportEvent byte

const (
	SportEventUncategorized  SportEvent = 0
	SportEventGeocaching     SportEvent = 1
	SportEventFitness        SportEvent = 2
	SportEventRecreation     SportEvent = 3
	SportEventRace           SportEvent = 4
	SportEventSpecialEvent   SportEvent = 5
	SportEventTraining       SportEvent = 6
	SportEventTransportation SportEvent = 7
	SportEventTouring        SportEvent = 8
	SportEventInvalid        SportEvent = 0xFF
)

// StrokeType represents the stroke_type FIT type.
type StrokeType byte

const (
	StrokeTypeNoEvent  StrokeType = 0
	StrokeTypeOther    StrokeType = 1 // stroke was detected but cannot be identified
	StrokeTypeServe    StrokeType = 2
	StrokeTypeForehand StrokeType = 3
	StrokeTypeBackhand StrokeType = 4
	StrokeTypeSmash    StrokeType = 5
	StrokeTypeInvalid  StrokeType = 0xFF
)

// SubSport represents the sub_sport FIT type.
type SubSport byte

const (
	SubSportGeneric              SubSport = 0
	SubSportTreadmill            SubSport = 1  // Run/Fitness Equipment
	SubSportStreet               SubSport = 2  // Run
	SubSportTrail                SubSport = 3  // Run
	SubSportTrack                SubSport = 4  // Run
	SubSportSpin                 SubSport = 5  // Cycling
	SubSportIndoorCycling        SubSport = 6  // Cycling/Fitness Equipment
	SubSportRoad                 SubSport = 7  // Cycling
	SubSportMountain             SubSport = 8  // Cycling
	SubSportDownhill             SubSport = 9  // Cycling
	SubSportRecumbent            SubSport = 10 // Cycling
	SubSportCyclocross           SubSport = 11 // Cycling
	SubSportHandCycling          SubSport = 12 // Cycling
	SubSportTrackCycling         SubSport = 13 // Cycling
	SubSportIndoorRowing         SubSport = 14 // Fitness Equipment
	SubSportElliptical           SubSport = 15 // Fitness Equipment
	SubSportStairClimbing        SubSport = 16 // Fitness Equipment
	SubSportLapSwimming          SubSport = 17 // Swimming
	SubSportOpenWater            SubSport = 18 // Swimming
	SubSportFlexibilityTraining  SubSport = 19 // Training
	SubSportStrengthTraining     SubSport = 20 // Training
	SubSportWarmUp               SubSport = 21 // Tennis
	SubSportMatch                SubSport = 22 // Tennis
	SubSportExercise             SubSport = 23 // Tennis
	SubSportChallenge            SubSport = 24 // Tennis
	SubSportIndoorSkiing         SubSport = 25 // Fitness Equipment
	SubSportCardioTraining       SubSport = 26 // Training
	SubSportIndoorWalking        SubSport = 27 // Walking/Fitness Equipment
	SubSportEBikeFitness         SubSport = 28 // E-Biking
	SubSportBmx                  SubSport = 29 // Cycling
	SubSportCasualWalking        SubSport = 30 // Walking
	SubSportSpeedWalking         SubSport = 31 // Walking
	SubSportBikeToRunTransition  SubSport = 32 // Transition
	SubSportRunToBikeTransition  SubSport = 33 // Transition
	SubSportSwimToBikeTransition SubSport = 34 // Transition
	SubSportAtv                  SubSport = 35 // Motorcycling
	SubSportMotocross            SubSport = 36 // Motorcycling
	SubSportBackcountry          SubSport = 37 // Alpine Skiing/Snowboarding
	SubSportResort               SubSport = 38 // Alpine Skiing/Snowboarding
	SubSportRcDrone              SubSport = 39 // Flying
	SubSportWingsuit             SubSport = 40 // Flying
	SubSportWhitewater           SubSport = 41 // Kayaking/Rafting
	SubSportAll                  SubSport = 254
	SubSportInvalid              SubSport = 0xFF
)

// SwimStroke represents the swim_stroke FIT type.
type SwimStroke byte

const (
	SwimStrokeFreestyle    SwimStroke = 0
	SwimStrokeBackstroke   SwimStroke = 1
	SwimStrokeBreaststroke SwimStroke = 2
	SwimStrokeButterfly    SwimStroke = 3
	SwimStrokeDrill        SwimStroke = 4
	SwimStrokeMixed        SwimStroke = 5
	SwimStrokeIm           SwimStroke = 6 // IM is a mixed interval containing the same number of lengths for each of: Butterfly, Backstroke, Breaststroke, Freestyle, swam in that order.
	SwimStrokeInvalid      SwimStroke = 0xFF
)

// TimeZone represents the time_zone FIT type.
type TimeZone byte

const (
	TimeZoneAlmaty                   TimeZone = 0
	TimeZoneBangkok                  TimeZone = 1
	TimeZoneBombay                   TimeZone = 2
	TimeZoneBrasilia                 TimeZone = 3
	TimeZoneCairo                    TimeZone = 4
	TimeZoneCapeVerdeIs              TimeZone = 5
	TimeZoneDarwin                   TimeZone = 6
	TimeZoneEniwetok                 TimeZone = 7
	TimeZoneFiji                     TimeZone = 8
	TimeZoneHongKong                 TimeZone = 9
	TimeZoneIslamabad                TimeZone = 10
	TimeZoneKabul                    TimeZone = 11
	TimeZoneMagadan                  TimeZone = 12
	TimeZoneMidAtlantic              TimeZone = 13
	TimeZoneMoscow                   TimeZone = 14
	TimeZoneMuscat                   TimeZone = 15
	TimeZoneNewfoundland             TimeZone = 16
	TimeZoneSamoa                    TimeZone = 17
	TimeZoneSydney                   TimeZone = 18
	TimeZoneTehran                   TimeZone = 19
	TimeZoneTokyo                    TimeZone = 20
	TimeZoneUsAlaska                 TimeZone = 21
	TimeZoneUsAtlantic               TimeZone = 22
	TimeZoneUsCentral                TimeZone = 23
	TimeZoneUsEastern                TimeZone = 24
	TimeZoneUsHawaii                 TimeZone = 25
	TimeZoneUsMountain               TimeZone = 26
	TimeZoneUsPacific                TimeZone = 27
	TimeZoneOther                    TimeZone = 28
	TimeZoneAuckland                 TimeZone = 29
	TimeZoneKathmandu                TimeZone = 30
	TimeZoneEuropeWesternWet         TimeZone = 31
	TimeZoneEuropeCentralCet         TimeZone = 32
	TimeZoneEuropeEasternEet         TimeZone = 33
	TimeZoneJakarta                  TimeZone = 34
	TimeZonePerth                    TimeZone = 35
	TimeZoneAdelaide                 TimeZone = 36
	TimeZoneBrisbane                 TimeZone = 37
	TimeZoneTasmania                 TimeZone = 38
	TimeZoneIceland                  TimeZone = 39
	TimeZoneAmsterdam                TimeZone = 40
	TimeZoneAthens                   TimeZone = 41
	TimeZoneBarcelona                TimeZone = 42
	TimeZoneBerlin                   TimeZone = 43
	TimeZoneBrussels                 TimeZone = 44
	TimeZoneBudapest                 TimeZone = 45
	TimeZoneCopenhagen               TimeZone = 46
	TimeZoneDublin                   TimeZone = 47
	TimeZoneHelsinki                 TimeZone = 48
	TimeZoneLisbon                   TimeZone = 49
	TimeZoneLondon                   TimeZone = 50
	TimeZoneMadrid                   TimeZone = 51
	TimeZoneMunich                   TimeZone = 52
	TimeZoneOslo                     TimeZone = 53
	TimeZoneParis                    TimeZone = 54
	TimeZonePrague                   TimeZone = 55
	TimeZoneReykjavik                TimeZone = 56
	TimeZoneRome                     TimeZone = 57
	TimeZoneStockholm                TimeZone = 58
	TimeZoneVienna                   TimeZone = 59
	TimeZoneWarsaw                   TimeZone = 60
	TimeZoneZurich                   TimeZone = 61
	TimeZoneQuebec                   TimeZone = 62
	TimeZoneOntario                  TimeZone = 63
	TimeZoneManitoba                 TimeZone = 64
	TimeZoneSaskatchewan             TimeZone = 65
	TimeZoneAlberta                  TimeZone = 66
	TimeZoneBritishColumbia          TimeZone = 67
	TimeZoneBoise                    TimeZone = 68
	TimeZoneBoston                   TimeZone = 69
	TimeZoneChicago                  TimeZone = 70
	TimeZoneDallas                   TimeZone = 71
	TimeZoneDenver                   TimeZone = 72
	TimeZoneKansasCity               TimeZone = 73
	TimeZoneLasVegas                 TimeZone = 74
	TimeZoneLosAngeles               TimeZone = 75
	TimeZoneMiami                    TimeZone = 76
	TimeZoneMinneapolis              TimeZone = 77
	TimeZoneNewYork                  TimeZone = 78
	TimeZoneNewOrleans               TimeZone = 79
	TimeZonePhoenix                  TimeZone = 80
	TimeZoneSantaFe                  TimeZone = 81
	TimeZoneSeattle                  TimeZone = 82
	TimeZoneWashingtonDc             TimeZone = 83
	TimeZoneUsArizona                TimeZone = 84
	TimeZoneChita                    TimeZone = 85
	TimeZoneEkaterinburg             TimeZone = 86
	TimeZoneIrkutsk                  TimeZone = 87
	TimeZoneKaliningrad              TimeZone = 88
	TimeZoneKrasnoyarsk              TimeZone = 89
	TimeZoneNovosibirsk              TimeZone = 90
	TimeZonePetropavlovskKamchatskiy TimeZone = 91
	TimeZoneSamara                   TimeZone = 92
	TimeZoneVladivostok              TimeZone = 93
	TimeZoneMexicoCentral            TimeZone = 94
	TimeZoneMexicoMountain           TimeZone = 95
	TimeZoneMexicoPacific            TimeZone = 96
	TimeZoneCapeTown                 TimeZone = 97
	TimeZoneWinkhoek                 TimeZone = 98
	TimeZoneLagos                    TimeZone = 99
	TimeZoneRiyahd                   TimeZone = 100
	TimeZoneVenezuela                TimeZone = 101
	TimeZoneAustraliaLh              TimeZone = 102
	TimeZoneSantiago                 TimeZone = 103
	TimeZoneManual                   TimeZone = 253
	TimeZoneAutomatic                TimeZone = 254
	TimeZoneInvalid                  TimeZone = 0xFF
)

// TimerTrigger represents the timer_trigger FIT type.
type TimerTrigger byte

const (
	TimerTriggerManual           TimerTrigger = 0
	TimerTriggerAuto             TimerTrigger = 1
	TimerTriggerFitnessEquipment TimerTrigger = 2
	TimerTriggerInvalid          TimerTrigger = 0xFF
)

// UserLocalId represents the user_local_id FIT type.
type UserLocalId uint16

const (
	UserLocalIdLocalMin      UserLocalId = 0x0000
	UserLocalIdLocalMax      UserLocalId = 0x000F
	UserLocalIdStationaryMin UserLocalId = 0x0010
	UserLocalIdStationaryMax UserLocalId = 0x00FF
	UserLocalIdPortableMin   UserLocalId = 0x0100
	UserLocalIdPortableMax   UserLocalId = 0xFFFE
	UserLocalIdInvalid       UserLocalId = 0xFFFF
)

// Weight represents the weight FIT type.
type Weight uint16

const (
	WeightCalculating Weight = 0xFFFE
	WeightInvalid     Weight = 0xFFFF
)

// WktStepDuration represents the wkt_step_duration FIT type.
type WktStepDuration byte

const (
	WktStepDurationTime                        WktStepDuration = 0
	WktStepDurationDistance                    WktStepDuration = 1
	WktStepDurationHrLessThan                  WktStepDuration = 2
	WktStepDurationHrGreaterThan               WktStepDuration = 3
	WktStepDurationCalories                    WktStepDuration = 4
	WktStepDurationOpen                        WktStepDuration = 5
	WktStepDurationRepeatUntilStepsCmplt       WktStepDuration = 6
	WktStepDurationRepeatUntilTime             WktStepDuration = 7
	WktStepDurationRepeatUntilDistance         WktStepDuration = 8
	WktStepDurationRepeatUntilCalories         WktStepDuration = 9
	WktStepDurationRepeatUntilHrLessThan       WktStepDuration = 10
	WktStepDurationRepeatUntilHrGreaterThan    WktStepDuration = 11
	WktStepDurationRepeatUntilPowerLessThan    WktStepDuration = 12
	WktStepDurationRepeatUntilPowerGreaterThan WktStepDuration = 13
	WktStepDurationPowerLessThan               WktStepDuration = 14
	WktStepDurationPowerGreaterThan            WktStepDuration = 15
	WktStepDurationRepetitionTime              WktStepDuration = 28
	WktStepDurationInvalid                     WktStepDuration = 0xFF
)

// WktStepTarget represents the wkt_step_target FIT type.
type WktStepTarget byte

const (
	WktStepTargetSpeed      WktStepTarget = 0
	WktStepTargetHeartRate  WktStepTarget = 1
	WktStepTargetOpen       WktStepTarget = 2
	WktStepTargetCadence    WktStepTarget = 3
	WktStepTargetPower      WktStepTarget = 4
	WktStepTargetGrade      WktStepTarget = 5
	WktStepTargetResistance WktStepTarget = 6
	WktStepTargetInvalid    WktStepTarget = 0xFF
)

// WorkoutCapabilities represents the workout_capabilities FIT type.
type WorkoutCapabilities uint32

const (
	WorkoutCapabilitiesInterval         WorkoutCapabilities = 0x00000001
	WorkoutCapabilitiesCustom           WorkoutCapabilities = 0x00000002
	WorkoutCapabilitiesFitnessEquipment WorkoutCapabilities = 0x00000004
	WorkoutCapabilitiesFirstbeat        WorkoutCapabilities = 0x00000008
	WorkoutCapabilitiesNewLeaf          WorkoutCapabilities = 0x00000010
	WorkoutCapabilitiesTcx              WorkoutCapabilities = 0x00000020 // For backwards compatibility.  Watch should add missing id fields then clear flag.
	WorkoutCapabilitiesSpeed            WorkoutCapabilities = 0x00000080 // Speed source required for workout step.
	WorkoutCapabilitiesHeartRate        WorkoutCapabilities = 0x00000100 // Heart rate source required for workout step.
	WorkoutCapabilitiesDistance         WorkoutCapabilities = 0x00000200 // Distance source required for workout step.
	WorkoutCapabilitiesCadence          WorkoutCapabilities = 0x00000400 // Cadence source required for workout step.
	WorkoutCapabilitiesPower            WorkoutCapabilities = 0x00000800 // Power source required for workout step.
	WorkoutCapabilitiesGrade            WorkoutCapabilities = 0x00001000 // Grade source required for workout step.
	WorkoutCapabilitiesResistance       WorkoutCapabilities = 0x00002000 // Resistance source required for workout step.
	WorkoutCapabilitiesProtected        WorkoutCapabilities = 0x00004000
	WorkoutCapabilitiesInvalid          WorkoutCapabilities = 0x00000000
)

// WorkoutHr represents the workout_hr FIT type.
type WorkoutHr uint32

const (
	WorkoutHrBpmOffset WorkoutHr = 100
	WorkoutHrInvalid   WorkoutHr = 0xFFFFFFFF
)

// WorkoutPower represents the workout_power FIT type.
type WorkoutPower uint32

const (
	WorkoutPowerWattsOffset WorkoutPower = 1000
	WorkoutPowerInvalid     WorkoutPower = 0xFFFFFFFF
)
// MESSAGES
// This file is auto-generated using the
// program found in 'cmd/fitgen/main.go'
// DO NOT EDIT.
// SDK Version: Unknown

package fit

import (
	"math"
	"time"
)

// FileIdMsg represents the file_id FIT message type.
type FileIdMsg struct {
	Type         File
	Manufacturer Manufacturer
	Product      uint16
	SerialNumber uint32
	TimeCreated  time.Time // Only set for files that are can be created/erased.
	Number       uint16    // Only set for files that are not created/erased.
	ProductName  string    // Optional free form string to indicate the devices name or model
}

// GetProduct returns the appropriate Product
// subfield if a matching reference field/value combination is found.
// If none of the reference field/value combinations are true
// then the main field is returned.
func (x *FileIdMsg) GetProduct() interface{} {
	switch x.Manufacturer {
	case ManufacturerGarmin, ManufacturerDynastream, ManufacturerDynastreamOem:
		return GarminProduct(x.Product)
	default:
		return x.Product
	}
}

// FileCreatorMsg represents the file_creator FIT message type.
type FileCreatorMsg struct {
	SoftwareVersion uint16
	HardwareVersion uint8
}

// TimestampCorrelationMsg represents the timestamp_correlation FIT message type.
type TimestampCorrelationMsg struct {
}

// SoftwareMsg represents the software FIT message type.
type SoftwareMsg struct {
	MessageIndex MessageIndex
	Version      uint16
	PartNumber   string
}

// GetVersionScaled returns Version
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
func (x *SoftwareMsg) GetVersionScaled() float64 {
	if x.Version == 0xFFFF {
		return math.NaN()
	}
	return float64(x.Version) / 100
}

// SlaveDeviceMsg represents the slave_device FIT message type.
type SlaveDeviceMsg struct {
	Manufacturer Manufacturer
	Product      uint16
}

// GetProduct returns the appropriate Product
// subfield if a matching reference field/value combination is found.
// If none of the reference field/value combinations are true
// then the main field is returned.
func (x *SlaveDeviceMsg) GetProduct() interface{} {
	switch x.Manufacturer {
	case ManufacturerGarmin, ManufacturerDynastream, ManufacturerDynastreamOem:
		return GarminProduct(x.Product)
	default:
		return x.Product
	}
}

// CapabilitiesMsg represents the capabilities FIT message type.
type CapabilitiesMsg struct {
	Languages             []uint8      // Use language_bits_x types where x is index of array.
	Sports                []SportBits0 // Use sport_bits_x types where x is index of array.
	WorkoutsSupported     WorkoutCapabilities
	ConnectivitySupported ConnectivityCapabilities
}

// FileCapabilitiesMsg represents the file_capabilities FIT message type.
type FileCapabilitiesMsg struct {
	MessageIndex MessageIndex
	Type         File
	Flags        FileFlags
	Directory    string
	MaxCount     uint16
	MaxSize      uint32
}

// MesgCapabilitiesMsg represents the mesg_capabilities FIT message type.
type MesgCapabilitiesMsg struct {
	MessageIndex MessageIndex
	File         File
	MesgNum      MesgNum
	CountType    MesgCount
	Count        uint16
}

// GetCount returns the appropriate Count
// subfield if a matching reference field/value combination is found.
// If none of the reference field/value combinations are true
// then the main field is returned.
func (x *MesgCapabilitiesMsg) GetCount() interface{} {
	switch x.CountType {
	case MesgCountNumPerFile:
		return uint16(x.Count)
	case MesgCountMaxPerFile:
		return uint16(x.Count)
	case MesgCountMaxPerFileType:
		return uint16(x.Count)
	default:
		return x.Count
	}
}

// FieldCapabilitiesMsg represents the field_capabilities FIT message type.
type FieldCapabilitiesMsg struct {
	MessageIndex MessageIndex
	File         File
	MesgNum      MesgNum
	FieldNum     uint8
	Count        uint16
}

// DeviceSettingsMsg represents the device_settings FIT message type.
type DeviceSettingsMsg struct {
	ActiveTimeZone uint8  // Index into time zone arrays.
	UtcOffset      uint32 // Offset from system time. Required to convert timestamp from system time to UTC.
	TimeZoneOffset []int8 // timezone offset in 1/4 hour increments
}

// GetTimeZoneOffsetScaled returns TimeZoneOffset
// as a slice with scale and any offset applied to every element.
// Units: hr
func (x *DeviceSettingsMsg) GetTimeZoneOffsetScaled() []float64 {
	if len(x.TimeZoneOffset) == 0 {
		return nil
	}
	s := make([]float64, len(x.TimeZoneOffset))
	for i, v := range x.TimeZoneOffset {
		s[i] = float64(v) / 4
	}
	return s
}

// UserProfileMsg represents the user_profile FIT message type.
type UserProfileMsg struct {
	MessageIndex               MessageIndex
	FriendlyName               string
	Gender                     Gender
	Age                        uint8
	Height                     uint8
	Weight                     uint16
	Language                   Language
	ElevSetting                DisplayMeasure
	WeightSetting              DisplayMeasure
	RestingHeartRate           uint8
	DefaultMaxRunningHeartRate uint8
	DefaultMaxBikingHeartRate  uint8
	DefaultMaxHeartRate        uint8
	HrSetting                  DisplayHeart
	SpeedSetting               DisplayMeasure
	DistSetting                DisplayMeasure
	PowerSetting               DisplayPower
	ActivityClass              ActivityClass
	PositionSetting            DisplayPosition
	TemperatureSetting         DisplayMeasure
	LocalId                    UserLocalId
	GlobalId                   []byte
	HeightSetting              DisplayMeasure
}

// GetHeightScaled returns Height
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: m
func (x *UserProfileMsg) GetHeightScaled() float64 {
	if x.Height == 0xFF {
		return math.NaN()
	}
	return float64(x.Height) / 100
}

// GetWeightScaled returns Weight
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: kg
func (x *UserProfileMsg) GetWeightScaled() float64 {
	if x.Weight == 0xFFFF {
		return math.NaN()
	}
	return float64(x.Weight) / 10
}

// HrmProfileMsg represents the hrm_profile FIT message type.
type HrmProfileMsg struct {
	MessageIndex      MessageIndex
	Enabled           Bool
	HrmAntId          uint16
	LogHrv            Bool
	HrmAntIdTransType uint8
}

// SdmProfileMsg represents the sdm_profile FIT message type.
type SdmProfileMsg struct {
	MessageIndex      MessageIndex
	Enabled           Bool
	SdmAntId          uint16
	SdmCalFactor      uint16
	Odometer          uint32
	SpeedSource       Bool // Use footpod for speed source instead of GPS
	SdmAntIdTransType uint8
	OdometerRollover  uint8 // Rollover counter that can be used to extend the odometer
}

// GetSdmCalFactorScaled returns SdmCalFactor
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: %
func (x *SdmProfileMsg) GetSdmCalFactorScaled() float64 {
	if x.SdmCalFactor == 0xFFFF {
		return math.NaN()
	}
	return float64(x.SdmCalFactor) / 10
}

// GetOdometerScaled returns Odometer
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: m
func (x *SdmProfileMsg) GetOdometerScaled() float64 {
	if x.Odometer == 0xFFFFFFFF {
		return math.NaN()
	}
	return float64(x.Odometer) / 100
}

// BikeProfileMsg represents the bike_profile FIT message type.
type BikeProfileMsg struct {
	MessageIndex             MessageIndex
	Name                     string
	Sport                    Sport
	SubSport                 SubSport
	Odometer                 uint32
	BikeSpdAntId             uint16
	BikeCadAntId             uint16
	BikeSpdcadAntId          uint16
	BikePowerAntId           uint16
	CustomWheelsize          uint16
	AutoWheelsize            uint16
	BikeWeight               uint16
	PowerCalFactor           uint16
	AutoWheelCal             Bool
	AutoPowerZero            Bool
	Id                       uint8
	SpdEnabled               Bool
	CadEnabled               Bool
	SpdcadEnabled            Bool
	PowerEnabled             Bool
	CrankLength              uint8
	Enabled                  Bool
	BikeSpdAntIdTransType    uint8
	BikeCadAntIdTransType    uint8
	BikeSpdcadAntIdTransType uint8
	BikePowerAntIdTransType  uint8
	OdometerRollover         uint8   // Rollover counter that can be used to extend the odometer
	FrontGearNum             uint8   // Number of front gears
	FrontGear                []uint8 // Number of teeth on each gear 0 is innermost
	RearGearNum              uint8   // Number of rear gears
	RearGear                 []uint8 // Number of teeth on each gear 0 is innermost
	ShimanoDi2Enabled        Bool
}

// GetOdometerScaled returns Odometer
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: m
func (x *BikeProfileMsg) GetOdometerScaled() float64 {
	if x.Odometer == 0xFFFFFFFF {
		return math.NaN()
	}
	return float64(x.Odometer) / 100
}

// GetCustomWheelsizeScaled returns CustomWheelsize
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: m
func (x *BikeProfileMsg) GetCustomWheelsizeScaled() float64 {
	if x.CustomWheelsize == 0xFFFF {
		return math.NaN()
	}
	return float64(x.CustomWheelsize) / 1000
}

// GetAutoWheelsizeScaled returns AutoWheelsize
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: m
func (x *BikeProfileMsg) GetAutoWheelsizeScaled() float64 {
	if x.AutoWheelsize == 0xFFFF {
		return math.NaN()
	}
	return float64(x.AutoWheelsize) / 1000
}

// GetBikeWeightScaled returns BikeWeight
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: kg
func (x *BikeProfileMsg) GetBikeWeightScaled() float64 {
	if x.BikeWeight == 0xFFFF {
		return math.NaN()
	}
	return float64(x.BikeWeight) / 10
}

// GetPowerCalFactorScaled returns PowerCalFactor
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: %
func (x *BikeProfileMsg) GetPowerCalFactorScaled() float64 {
	if x.PowerCalFactor == 0xFFFF {
		return math.NaN()
	}
	return float64(x.PowerCalFactor) / 10
}

// GetCrankLengthScaled returns CrankLength
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: mm
func (x *BikeProfileMsg) GetCrankLengthScaled() float64 {
	if x.CrankLength == 0xFF {
		return math.NaN()
	}
	return float64(x.CrankLength)/2 - -110
}

// ZonesTargetMsg represents the zones_target FIT message type.
type ZonesTargetMsg struct {
	MaxHeartRate             uint8
	ThresholdHeartRate       uint8
	FunctionalThresholdPower uint16
	HrCalcType               HrZoneCalc
	PwrCalcType              PwrZoneCalc
}

// SportMsg represents the sport FIT message type.
type SportMsg struct {
	Sport    Sport
	SubSport SubSport
	Name     string
}

// HrZoneMsg represents the hr_zone FIT message type.
type HrZoneMsg struct {
	MessageIndex MessageIndex
	HighBpm      uint8
	Name         string
}

// SpeedZoneMsg represents the speed_zone FIT message type.
type SpeedZoneMsg struct {
	MessageIndex MessageIndex
	HighValue    uint16
	Name         string
}

// GetHighValueScaled returns HighValue
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: m/s
func (x *SpeedZoneMsg) GetHighValueScaled() float64 {
	if x.HighValue == 0xFFFF {
		return math.NaN()
	}
	return float64(x.HighValue) / 1000
}

// CadenceZoneMsg represents the cadence_zone FIT message type.
type CadenceZoneMsg struct {
	MessageIndex MessageIndex
	HighValue    uint8
	Name         string
}

// PowerZoneMsg represents the power_zone FIT message type.
type PowerZoneMsg struct {
	MessageIndex MessageIndex
	HighValue    uint16
	Name         string
}

// MetZoneMsg represents the met_zone FIT message type.
type MetZoneMsg struct {
	MessageIndex MessageIndex
	HighBpm      uint8
	Calories     uint16
	FatCalories  uint8
}

// GetCaloriesScaled returns Calories
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: kcal / min
func (x *MetZoneMsg) GetCaloriesScaled() float64 {
	if x.Calories == 0xFFFF {
		return math.NaN()
	}
	return float64(x.Calories) / 10
}

// GetFatCaloriesScaled returns FatCalories
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: kcal / min
func (x *MetZoneMsg) GetFatCaloriesScaled() float64 {
	if x.FatCalories == 0xFF {
		return math.NaN()
	}
	return float64(x.FatCalories) / 10
}

// GoalMsg represents the goal FIT message type.
type GoalMsg struct {
	MessageIndex    MessageIndex
	Sport           Sport
	SubSport        SubSport
	StartDate       time.Time
	EndDate         time.Time
	Type            Goal
	Value           uint32
	Repeat          Bool
	TargetValue     uint32
	Recurrence      GoalRecurrence
	RecurrenceValue uint16
	Enabled         Bool
}

// ActivityMsg represents the activity FIT message type.
type ActivityMsg struct {
	Timestamp      time.Time
	TotalTimerTime uint32 // Exclude pauses
	NumSessions    uint16
	Type           ActivityMode
	Event          Event
	EventType      EventType
	LocalTimestamp time.Time // timestamp epoch expressed in local time, used to convert activity timestamps to local time
	EventGroup     uint8
}

// GetTotalTimerTimeScaled returns TotalTimerTime
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: s
func (x *ActivityMsg) GetTotalTimerTimeScaled() float64 {
	if x.TotalTimerTime == 0xFFFFFFFF {
		return math.NaN()
	}
	return float64(x.TotalTimerTime) / 1000
}

// SessionMsg represents the session FIT message type.
type SessionMsg struct {
	MessageIndex           MessageIndex // Selected bit is set for the current session.
	Timestamp              time.Time    // Sesson end time.
	Event                  Event        // session
	EventType              EventType    // stop
	StartTime              time.Time
	StartPositionLat       Latitude
	StartPositionLong      Longitude
	Sport                  Sport
	SubSport               SubSport
	TotalElapsedTime       uint32 // Time (includes pauses)
	TotalTimerTime         uint32 // Timer Time (excludes pauses)
	TotalDistance          uint32
	TotalCycles            uint32
	TotalCalories          uint16
	TotalFatCalories       uint16
	AvgSpeed               uint16 // total_distance / total_timer_time
	MaxSpeed               uint16
	AvgHeartRate           uint8 // average heart rate (excludes pause time)
	MaxHeartRate           uint8
	AvgCadence             uint8 // total_cycles / total_timer_time if non_zero_avg_cadence otherwise total_cycles / total_elapsed_time
	MaxCadence             uint8
	AvgPower               uint16 // total_power / total_timer_time if non_zero_avg_power otherwise total_power / total_elapsed_time
	MaxPower               uint16
	TotalAscent            uint16
	TotalDescent           uint16
	TotalTrainingEffect    uint8
	FirstLapIndex          uint16
	NumLaps                uint16
	EventGroup             uint8
	Trigger                SessionTrigger
	NecLat                 Latitude
	NecLong                Longitude
	SwcLat                 Latitude
	SwcLong                Longitude
	NormalizedPower        uint16
	TrainingStressScore    uint16
	IntensityFactor        uint16
	LeftRightBalance       LeftRightBalance100
	AvgStrokeCount         uint32
	AvgStrokeDistance      uint16
	SwimStroke             SwimStroke
	PoolLength             uint16
	ThresholdPower         uint16
	PoolLengthUnit         DisplayMeasure
	NumActiveLengths       uint16 // # of active lengths of swim pool
	TotalWork              uint32
	AvgAltitude            uint16
	MaxAltitude            uint16
	GpsAccuracy            uint8
	AvgGrade               int16
	AvgPosGrade            int16
	AvgNegGrade            int16
	MaxPosGrade            int16
	MaxNegGrade            int16
	AvgTemperature         int8
	MaxTemperature         int8
	TotalMovingTime        uint32
	AvgPosVerticalSpeed    int16
	AvgNegVerticalSpeed    int16
	MaxPosVerticalSpeed    int16
	MaxNegVerticalSpeed    int16
	MinHeartRate           uint8
	TimeInHrZone           []uint32
	TimeInSpeedZone        []uint32
	TimeInCadenceZone      []uint32
	TimeInPowerZone        []uint32
	AvgLapTime             uint32
	BestLapIndex           uint16
	MinAltitude            uint16
	PlayerScore            uint16
	OpponentScore          uint16
	OpponentName           string
	StrokeCount            []uint16 // stroke_type enum used as the index
	ZoneCount              []uint16 // zone number used as the index
	MaxBallSpeed           uint16
	AvgBallSpeed           uint16
	AvgVerticalOscillation uint16
	AvgStanceTimePercent   uint16
	AvgStanceTime          uint16
	AvgFractionalCadence   uint8 // fractional part of the avg_cadence
	MaxFractionalCadence   uint8 // fractional part of the max_cadence
	TotalFractionalCycles  uint8 // fractional part of the total_cycles
	SportIndex             uint8
	EnhancedAvgSpeed       uint32 // total_distance / total_timer_time
	EnhancedMaxSpeed       uint32
	EnhancedAvgAltitude    uint32
	EnhancedMinAltitude    uint32
	EnhancedMaxAltitude    uint32
}

// GetTotalElapsedTimeScaled returns TotalElapsedTime
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: s
func (x *SessionMsg) GetTotalElapsedTimeScaled() float64 {
	if x.TotalElapsedTime == 0xFFFFFFFF {
		return math.NaN()
	}
	return float64(x.TotalElapsedTime) / 1000
}

// GetTotalTimerTimeScaled returns TotalTimerTime
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: s
func (x *SessionMsg) GetTotalTimerTimeScaled() float64 {
	if x.TotalTimerTime == 0xFFFFFFFF {
		return math.NaN()
	}
	return float64(x.TotalTimerTime) / 1000
}

// GetTotalDistanceScaled returns TotalDistance
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: m
func (x *SessionMsg) GetTotalDistanceScaled() float64 {
	if x.TotalDistance == 0xFFFFFFFF {
		return math.NaN()
	}
	return float64(x.TotalDistance) / 100
}

// GetAvgSpeedScaled returns AvgSpeed
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: m/s
func (x *SessionMsg) GetAvgSpeedScaled() float64 {
	if x.AvgSpeed == 0xFFFF {
		return math.NaN()
	}
	return float64(x.AvgSpeed) / 1000
}

// GetMaxSpeedScaled returns MaxSpeed
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: m/s
func (x *SessionMsg) GetMaxSpeedScaled() float64 {
	if x.MaxSpeed == 0xFFFF {
		return math.NaN()
	}
	return float64(x.MaxSpeed) / 1000
}

// GetTotalTrainingEffectScaled returns TotalTrainingEffect
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
func (x *SessionMsg) GetTotalTrainingEffectScaled() float64 {
	if x.TotalTrainingEffect == 0xFF {
		return math.NaN()
	}
	return float64(x.TotalTrainingEffect) / 10
}

// GetTrainingStressScoreScaled returns TrainingStressScore
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: tss
func (x *SessionMsg) GetTrainingStressScoreScaled() float64 {
	if x.TrainingStressScore == 0xFFFF {
		return math.NaN()
	}
	return float64(x.TrainingStressScore) / 10
}

// GetIntensityFactorScaled returns IntensityFactor
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: if
func (x *SessionMsg) GetIntensityFactorScaled() float64 {
	if x.IntensityFactor == 0xFFFF {
		return math.NaN()
	}
	return float64(x.IntensityFactor) / 1000
}

// GetAvgStrokeCountScaled returns AvgStrokeCount
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: strokes/lap
func (x *SessionMsg) GetAvgStrokeCountScaled() float64 {
	if x.AvgStrokeCount == 0xFFFFFFFF {
		return math.NaN()
	}
	return float64(x.AvgStrokeCount) / 10
}

// GetAvgStrokeDistanceScaled returns AvgStrokeDistance
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: m
func (x *SessionMsg) GetAvgStrokeDistanceScaled() float64 {
	if x.AvgStrokeDistance == 0xFFFF {
		return math.NaN()
	}
	return float64(x.AvgStrokeDistance) / 100
}

// GetPoolLengthScaled returns PoolLength
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: m
func (x *SessionMsg) GetPoolLengthScaled() float64 {
	if x.PoolLength == 0xFFFF {
		return math.NaN()
	}
	return float64(x.PoolLength) / 100
}

// GetAvgAltitudeScaled returns AvgAltitude
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: m
func (x *SessionMsg) GetAvgAltitudeScaled() float64 {
	if x.AvgAltitude == 0xFFFF {
		return math.NaN()
	}
	return float64(x.AvgAltitude)/5 - 500
}

// GetMaxAltitudeScaled returns MaxAltitude
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: m
func (x *SessionMsg) GetMaxAltitudeScaled() float64 {
	if x.MaxAltitude == 0xFFFF {
		return math.NaN()
	}
	return float64(x.MaxAltitude)/5 - 500
}

// GetAvgGradeScaled returns AvgGrade
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: %
func (x *SessionMsg) GetAvgGradeScaled() float64 {
	if x.AvgGrade == 0x7FFF {
		return math.NaN()
	}
	return float64(x.AvgGrade) / 100
}

// GetAvgPosGradeScaled returns AvgPosGrade
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: %
func (x *SessionMsg) GetAvgPosGradeScaled() float64 {
	if x.AvgPosGrade == 0x7FFF {
		return math.NaN()
	}
	return float64(x.AvgPosGrade) / 100
}

// GetAvgNegGradeScaled returns AvgNegGrade
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: %
func (x *SessionMsg) GetAvgNegGradeScaled() float64 {
	if x.AvgNegGrade == 0x7FFF {
		return math.NaN()
	}
	return float64(x.AvgNegGrade) / 100
}

// GetMaxPosGradeScaled returns MaxPosGrade
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: %
func (x *SessionMsg) GetMaxPosGradeScaled() float64 {
	if x.MaxPosGrade == 0x7FFF {
		return math.NaN()
	}
	return float64(x.MaxPosGrade) / 100
}

// GetMaxNegGradeScaled returns MaxNegGrade
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: %
func (x *SessionMsg) GetMaxNegGradeScaled() float64 {
	if x.MaxNegGrade == 0x7FFF {
		return math.NaN()
	}
	return float64(x.MaxNegGrade) / 100
}

// GetTotalMovingTimeScaled returns TotalMovingTime
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: s
func (x *SessionMsg) GetTotalMovingTimeScaled() float64 {
	if x.TotalMovingTime == 0xFFFFFFFF {
		return math.NaN()
	}
	return float64(x.TotalMovingTime) / 1000
}

// GetAvgPosVerticalSpeedScaled returns AvgPosVerticalSpeed
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: m/s
func (x *SessionMsg) GetAvgPosVerticalSpeedScaled() float64 {
	if x.AvgPosVerticalSpeed == 0x7FFF {
		return math.NaN()
	}
	return float64(x.AvgPosVerticalSpeed) / 1000
}

// GetAvgNegVerticalSpeedScaled returns AvgNegVerticalSpeed
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: m/s
func (x *SessionMsg) GetAvgNegVerticalSpeedScaled() float64 {
	if x.AvgNegVerticalSpeed == 0x7FFF {
		return math.NaN()
	}
	return float64(x.AvgNegVerticalSpeed) / 1000
}

// GetMaxPosVerticalSpeedScaled returns MaxPosVerticalSpeed
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: m/s
func (x *SessionMsg) GetMaxPosVerticalSpeedScaled() float64 {
	if x.MaxPosVerticalSpeed == 0x7FFF {
		return math.NaN()
	}
	return float64(x.MaxPosVerticalSpeed) / 1000
}

// GetMaxNegVerticalSpeedScaled returns MaxNegVerticalSpeed
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: m/s
func (x *SessionMsg) GetMaxNegVerticalSpeedScaled() float64 {
	if x.MaxNegVerticalSpeed == 0x7FFF {
		return math.NaN()
	}
	return float64(x.MaxNegVerticalSpeed) / 1000
}

// GetTimeInHrZoneScaled returns TimeInHrZone
// as a slice with scale and any offset applied to every element.
// Units: s
func (x *SessionMsg) GetTimeInHrZoneScaled() []float64 {
	if len(x.TimeInHrZone) == 0 {
		return nil
	}
	s := make([]float64, len(x.TimeInHrZone))
	for i, v := range x.TimeInHrZone {
		s[i] = float64(v) / 1000
	}
	return s
}

// GetTimeInSpeedZoneScaled returns TimeInSpeedZone
// as a slice with scale and any offset applied to every element.
// Units: s
func (x *SessionMsg) GetTimeInSpeedZoneScaled() []float64 {
	if len(x.TimeInSpeedZone) == 0 {
		return nil
	}
	s := make([]float64, len(x.TimeInSpeedZone))
	for i, v := range x.TimeInSpeedZone {
		s[i] = float64(v) / 1000
	}
	return s
}

// GetTimeInCadenceZoneScaled returns TimeInCadenceZone
// as a slice with scale and any offset applied to every element.
// Units: s
func (x *SessionMsg) GetTimeInCadenceZoneScaled() []float64 {
	if len(x.TimeInCadenceZone) == 0 {
		return nil
	}
	s := make([]float64, len(x.TimeInCadenceZone))
	for i, v := range x.TimeInCadenceZone {
		s[i] = float64(v) / 1000
	}
	return s
}

// GetTimeInPowerZoneScaled returns TimeInPowerZone
// as a slice with scale and any offset applied to every element.
// Units: s
func (x *SessionMsg) GetTimeInPowerZoneScaled() []float64 {
	if len(x.TimeInPowerZone) == 0 {
		return nil
	}
	s := make([]float64, len(x.TimeInPowerZone))
	for i, v := range x.TimeInPowerZone {
		s[i] = float64(v) / 1000
	}
	return s
}

// GetAvgLapTimeScaled returns AvgLapTime
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: s
func (x *SessionMsg) GetAvgLapTimeScaled() float64 {
	if x.AvgLapTime == 0xFFFFFFFF {
		return math.NaN()
	}
	return float64(x.AvgLapTime) / 1000
}

// GetMinAltitudeScaled returns MinAltitude
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: m
func (x *SessionMsg) GetMinAltitudeScaled() float64 {
	if x.MinAltitude == 0xFFFF {
		return math.NaN()
	}
	return float64(x.MinAltitude)/5 - 500
}

// GetMaxBallSpeedScaled returns MaxBallSpeed
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: m/s
func (x *SessionMsg) GetMaxBallSpeedScaled() float64 {
	if x.MaxBallSpeed == 0xFFFF {
		return math.NaN()
	}
	return float64(x.MaxBallSpeed) / 100
}

// GetAvgBallSpeedScaled returns AvgBallSpeed
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: m/s
func (x *SessionMsg) GetAvgBallSpeedScaled() float64 {
	if x.AvgBallSpeed == 0xFFFF {
		return math.NaN()
	}
	return float64(x.AvgBallSpeed) / 100
}

// GetAvgVerticalOscillationScaled returns AvgVerticalOscillation
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: mm
func (x *SessionMsg) GetAvgVerticalOscillationScaled() float64 {
	if x.AvgVerticalOscillation == 0xFFFF {
		return math.NaN()
	}
	return float64(x.AvgVerticalOscillation) / 10
}

// GetAvgStanceTimePercentScaled returns AvgStanceTimePercent
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: percent
func (x *SessionMsg) GetAvgStanceTimePercentScaled() float64 {
	if x.AvgStanceTimePercent == 0xFFFF {
		return math.NaN()
	}
	return float64(x.AvgStanceTimePercent) / 100
}

// GetAvgStanceTimeScaled returns AvgStanceTime
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: ms
func (x *SessionMsg) GetAvgStanceTimeScaled() float64 {
	if x.AvgStanceTime == 0xFFFF {
		return math.NaN()
	}
	return float64(x.AvgStanceTime) / 10
}

// GetAvgFractionalCadenceScaled returns AvgFractionalCadence
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: rpm
func (x *SessionMsg) GetAvgFractionalCadenceScaled() float64 {
	if x.AvgFractionalCadence == 0xFF {
		return math.NaN()
	}
	return float64(x.AvgFractionalCadence) / 128
}

// GetMaxFractionalCadenceScaled returns MaxFractionalCadence
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: rpm
func (x *SessionMsg) GetMaxFractionalCadenceScaled() float64 {
	if x.MaxFractionalCadence == 0xFF {
		return math.NaN()
	}
	return float64(x.MaxFractionalCadence) / 128
}

// GetTotalFractionalCyclesScaled returns TotalFractionalCycles
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: cycles
func (x *SessionMsg) GetTotalFractionalCyclesScaled() float64 {
	if x.TotalFractionalCycles == 0xFF {
		return math.NaN()
	}
	return float64(x.TotalFractionalCycles) / 128
}

// GetEnhancedAvgSpeedScaled returns EnhancedAvgSpeed
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: m/s
func (x *SessionMsg) GetEnhancedAvgSpeedScaled() float64 {
	if x.EnhancedAvgSpeed == 0xFFFFFFFF {
		return math.NaN()
	}
	return float64(x.EnhancedAvgSpeed) / 1000
}

// GetEnhancedMaxSpeedScaled returns EnhancedMaxSpeed
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: m/s
func (x *SessionMsg) GetEnhancedMaxSpeedScaled() float64 {
	if x.EnhancedMaxSpeed == 0xFFFFFFFF {
		return math.NaN()
	}
	return float64(x.EnhancedMaxSpeed) / 1000
}

// GetEnhancedAvgAltitudeScaled returns EnhancedAvgAltitude
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: m
func (x *SessionMsg) GetEnhancedAvgAltitudeScaled() float64 {
	if x.EnhancedAvgAltitude == 0xFFFFFFFF {
		return math.NaN()
	}
	return float64(x.EnhancedAvgAltitude)/5 - 500
}

// GetEnhancedMinAltitudeScaled returns EnhancedMinAltitude
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: m
func (x *SessionMsg) GetEnhancedMinAltitudeScaled() float64 {
	if x.EnhancedMinAltitude == 0xFFFFFFFF {
		return math.NaN()
	}
	return float64(x.EnhancedMinAltitude)/5 - 500
}

// GetEnhancedMaxAltitudeScaled returns EnhancedMaxAltitude
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: m
func (x *SessionMsg) GetEnhancedMaxAltitudeScaled() float64 {
	if x.EnhancedMaxAltitude == 0xFFFFFFFF {
		return math.NaN()
	}
	return float64(x.EnhancedMaxAltitude)/5 - 500
}

// GetTotalCycles returns the appropriate TotalCycles
// subfield if a matching reference field/value combination is found.
// If none of the reference field/value combinations are true
// then the main field is returned.
func (x *SessionMsg) GetTotalCycles() interface{} {
	switch x.Sport {
	case SportRunning, SportWalking:
		return uint32(x.TotalCycles)
	default:
		return x.TotalCycles
	}
}

// GetAvgCadence returns the appropriate AvgCadence
// subfield if a matching reference field/value combination is found.
// If none of the reference field/value combinations are true
// then the main field is returned.
func (x *SessionMsg) GetAvgCadence() interface{} {
	switch x.Sport {
	case SportRunning:
		return uint8(x.AvgCadence)
	default:
		return x.AvgCadence
	}
}

// GetMaxCadence returns the appropriate MaxCadence
// subfield if a matching reference field/value combination is found.
// If none of the reference field/value combinations are true
// then the main field is returned.
func (x *SessionMsg) GetMaxCadence() interface{} {
	switch x.Sport {
	case SportRunning:
		return uint8(x.MaxCadence)
	default:
		return x.MaxCadence
	}
}

func (x *SessionMsg) expandComponents() {
	if x.AvgSpeed != 0xFFFF {
		x.EnhancedAvgSpeed = uint32(
			(x.AvgSpeed >> 0) & ((1 << 16) - 1),
		)
	}
	if x.MaxSpeed != 0xFFFF {
		x.EnhancedMaxSpeed = uint32(
			(x.MaxSpeed >> 0) & ((1 << 16) - 1),
		)
	}
	if x.AvgAltitude != 0xFFFF {
		x.EnhancedAvgAltitude = uint32(
			(x.AvgAltitude >> 0) & ((1 << 16) - 1),
		)
	}
	if x.MaxAltitude != 0xFFFF {
		x.EnhancedMaxAltitude = uint32(
			(x.MaxAltitude >> 0) & ((1 << 16) - 1),
		)
	}
	if x.MinAltitude != 0xFFFF {
		x.EnhancedMinAltitude = uint32(
			(x.MinAltitude >> 0) & ((1 << 16) - 1),
		)
	}
}

// LapMsg represents the lap FIT message type.
type LapMsg struct {
	MessageIndex                  MessageIndex
	Timestamp                     time.Time // Lap end time.
	Event                         Event
	EventType                     EventType
	StartTime                     time.Time
	StartPositionLat              Latitude
	StartPositionLong             Longitude
	EndPositionLat                Latitude
	EndPositionLong               Longitude
	TotalElapsedTime              uint32 // Time (includes pauses)
	TotalTimerTime                uint32 // Timer Time (excludes pauses)
	TotalDistance                 uint32
	TotalCycles                   uint32
	TotalCalories                 uint16
	TotalFatCalories              uint16 // If New Leaf
	AvgSpeed                      uint16
	MaxSpeed                      uint16
	AvgHeartRate                  uint8
	MaxHeartRate                  uint8
	AvgCadence                    uint8 // total_cycles / total_timer_time if non_zero_avg_cadence otherwise total_cycles / total_elapsed_time
	MaxCadence                    uint8
	AvgPower                      uint16 // total_power / total_timer_time if non_zero_avg_power otherwise total_power / total_elapsed_time
	MaxPower                      uint16
	TotalAscent                   uint16
	TotalDescent                  uint16
	Intensity                     Intensity
	LapTrigger                    LapTrigger
	Sport                         Sport
	EventGroup                    uint8
	NumLengths                    uint16 // # of lengths of swim pool
	NormalizedPower               uint16
	LeftRightBalance              LeftRightBalance100
	FirstLengthIndex              uint16
	AvgStrokeDistance             uint16
	SwimStroke                    SwimStroke
	SubSport                      SubSport
	NumActiveLengths              uint16 // # of active lengths of swim pool
	TotalWork                     uint32
	AvgAltitude                   uint16
	MaxAltitude                   uint16
	GpsAccuracy                   uint8
	AvgGrade                      int16
	AvgPosGrade                   int16
	AvgNegGrade                   int16
	MaxPosGrade                   int16
	MaxNegGrade                   int16
	AvgTemperature                int8
	MaxTemperature                int8
	TotalMovingTime               uint32
	AvgPosVerticalSpeed           int16
	AvgNegVerticalSpeed           int16
	MaxPosVerticalSpeed           int16
	MaxNegVerticalSpeed           int16
	TimeInHrZone                  []uint32
	TimeInSpeedZone               []uint32
	TimeInCadenceZone             []uint32
	TimeInPowerZone               []uint32
	RepetitionNum                 uint16
	MinAltitude                   uint16
	MinHeartRate                  uint8
	WktStepIndex                  MessageIndex
	OpponentScore                 uint16
	StrokeCount                   []uint16 // stroke_type enum used as the index
	ZoneCount                     []uint16 // zone number used as the index
	AvgVerticalOscillation        uint16
	AvgStanceTimePercent          uint16
	AvgStanceTime                 uint16
	AvgFractionalCadence          uint8 // fractional part of the avg_cadence
	MaxFractionalCadence          uint8 // fractional part of the max_cadence
	TotalFractionalCycles         uint8 // fractional part of the total_cycles
	PlayerScore                   uint16
	AvgTotalHemoglobinConc        []uint16 // Avg saturated and unsaturated hemoglobin
	MinTotalHemoglobinConc        []uint16 // Min saturated and unsaturated hemoglobin
	MaxTotalHemoglobinConc        []uint16 // Max saturated and unsaturated hemoglobin
	AvgSaturatedHemoglobinPercent []uint16 // Avg percentage of hemoglobin saturated with oxygen
	MinSaturatedHemoglobinPercent []uint16 // Min percentage of hemoglobin saturated with oxygen
	MaxSaturatedHemoglobinPercent []uint16 // Max percentage of hemoglobin saturated with oxygen
	EnhancedAvgSpeed              uint32
	EnhancedMaxSpeed              uint32
	EnhancedAvgAltitude           uint32
	EnhancedMinAltitude           uint32
	EnhancedMaxAltitude           uint32
}

// GetTotalElapsedTimeScaled returns TotalElapsedTime
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: s
func (x *LapMsg) GetTotalElapsedTimeScaled() float64 {
	if x.TotalElapsedTime == 0xFFFFFFFF {
		return math.NaN()
	}
	return float64(x.TotalElapsedTime) / 1000
}

// GetTotalTimerTimeScaled returns TotalTimerTime
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: s
func (x *LapMsg) GetTotalTimerTimeScaled() float64 {
	if x.TotalTimerTime == 0xFFFFFFFF {
		return math.NaN()
	}
	return float64(x.TotalTimerTime) / 1000
}

// GetTotalDistanceScaled returns TotalDistance
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: m
func (x *LapMsg) GetTotalDistanceScaled() float64 {
	if x.TotalDistance == 0xFFFFFFFF {
		return math.NaN()
	}
	return float64(x.TotalDistance) / 100
}

// GetAvgSpeedScaled returns AvgSpeed
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: m/s
func (x *LapMsg) GetAvgSpeedScaled() float64 {
	if x.AvgSpeed == 0xFFFF {
		return math.NaN()
	}
	return float64(x.AvgSpeed) / 1000
}

// GetMaxSpeedScaled returns MaxSpeed
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: m/s
func (x *LapMsg) GetMaxSpeedScaled() float64 {
	if x.MaxSpeed == 0xFFFF {
		return math.NaN()
	}
	return float64(x.MaxSpeed) / 1000
}

// GetAvgStrokeDistanceScaled returns AvgStrokeDistance
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: m
func (x *LapMsg) GetAvgStrokeDistanceScaled() float64 {
	if x.AvgStrokeDistance == 0xFFFF {
		return math.NaN()
	}
	return float64(x.AvgStrokeDistance) / 100
}

// GetAvgAltitudeScaled returns AvgAltitude
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: m
func (x *LapMsg) GetAvgAltitudeScaled() float64 {
	if x.AvgAltitude == 0xFFFF {
		return math.NaN()
	}
	return float64(x.AvgAltitude)/5 - 500
}

// GetMaxAltitudeScaled returns MaxAltitude
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: m
func (x *LapMsg) GetMaxAltitudeScaled() float64 {
	if x.MaxAltitude == 0xFFFF {
		return math.NaN()
	}
	return float64(x.MaxAltitude)/5 - 500
}

// GetAvgGradeScaled returns AvgGrade
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: %
func (x *LapMsg) GetAvgGradeScaled() float64 {
	if x.AvgGrade == 0x7FFF {
		return math.NaN()
	}
	return float64(x.AvgGrade) / 100
}

// GetAvgPosGradeScaled returns AvgPosGrade
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: %
func (x *LapMsg) GetAvgPosGradeScaled() float64 {
	if x.AvgPosGrade == 0x7FFF {
		return math.NaN()
	}
	return float64(x.AvgPosGrade) / 100
}

// GetAvgNegGradeScaled returns AvgNegGrade
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: %
func (x *LapMsg) GetAvgNegGradeScaled() float64 {
	if x.AvgNegGrade == 0x7FFF {
		return math.NaN()
	}
	return float64(x.AvgNegGrade) / 100
}

// GetMaxPosGradeScaled returns MaxPosGrade
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: %
func (x *LapMsg) GetMaxPosGradeScaled() float64 {
	if x.MaxPosGrade == 0x7FFF {
		return math.NaN()
	}
	return float64(x.MaxPosGrade) / 100
}

// GetMaxNegGradeScaled returns MaxNegGrade
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: %
func (x *LapMsg) GetMaxNegGradeScaled() float64 {
	if x.MaxNegGrade == 0x7FFF {
		return math.NaN()
	}
	return float64(x.MaxNegGrade) / 100
}

// GetTotalMovingTimeScaled returns TotalMovingTime
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: s
func (x *LapMsg) GetTotalMovingTimeScaled() float64 {
	if x.TotalMovingTime == 0xFFFFFFFF {
		return math.NaN()
	}
	return float64(x.TotalMovingTime) / 1000
}

// GetAvgPosVerticalSpeedScaled returns AvgPosVerticalSpeed
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: m/s
func (x *LapMsg) GetAvgPosVerticalSpeedScaled() float64 {
	if x.AvgPosVerticalSpeed == 0x7FFF {
		return math.NaN()
	}
	return float64(x.AvgPosVerticalSpeed) / 1000
}

// GetAvgNegVerticalSpeedScaled returns AvgNegVerticalSpeed
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: m/s
func (x *LapMsg) GetAvgNegVerticalSpeedScaled() float64 {
	if x.AvgNegVerticalSpeed == 0x7FFF {
		return math.NaN()
	}
	return float64(x.AvgNegVerticalSpeed) / 1000
}

// GetMaxPosVerticalSpeedScaled returns MaxPosVerticalSpeed
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: m/s
func (x *LapMsg) GetMaxPosVerticalSpeedScaled() float64 {
	if x.MaxPosVerticalSpeed == 0x7FFF {
		return math.NaN()
	}
	return float64(x.MaxPosVerticalSpeed) / 1000
}

// GetMaxNegVerticalSpeedScaled returns MaxNegVerticalSpeed
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: m/s
func (x *LapMsg) GetMaxNegVerticalSpeedScaled() float64 {
	if x.MaxNegVerticalSpeed == 0x7FFF {
		return math.NaN()
	}
	return float64(x.MaxNegVerticalSpeed) / 1000
}

// GetTimeInHrZoneScaled returns TimeInHrZone
// as a slice with scale and any offset applied to every element.
// Units: s
func (x *LapMsg) GetTimeInHrZoneScaled() []float64 {
	if len(x.TimeInHrZone) == 0 {
		return nil
	}
	s := make([]float64, len(x.TimeInHrZone))
	for i, v := range x.TimeInHrZone {
		s[i] = float64(v) / 1000
	}
	return s
}

// GetTimeInSpeedZoneScaled returns TimeInSpeedZone
// as a slice with scale and any offset applied to every element.
// Units: s
func (x *LapMsg) GetTimeInSpeedZoneScaled() []float64 {
	if len(x.TimeInSpeedZone) == 0 {
		return nil
	}
	s := make([]float64, len(x.TimeInSpeedZone))
	for i, v := range x.TimeInSpeedZone {
		s[i] = float64(v) / 1000
	}
	return s
}

// GetTimeInCadenceZoneScaled returns TimeInCadenceZone
// as a slice with scale and any offset applied to every element.
// Units: s
func (x *LapMsg) GetTimeInCadenceZoneScaled() []float64 {
	if len(x.TimeInCadenceZone) == 0 {
		return nil
	}
	s := make([]float64, len(x.TimeInCadenceZone))
	for i, v := range x.TimeInCadenceZone {
		s[i] = float64(v) / 1000
	}
	return s
}

// GetTimeInPowerZoneScaled returns TimeInPowerZone
// as a slice with scale and any offset applied to every element.
// Units: s
func (x *LapMsg) GetTimeInPowerZoneScaled() []float64 {
	if len(x.TimeInPowerZone) == 0 {
		return nil
	}
	s := make([]float64, len(x.TimeInPowerZone))
	for i, v := range x.TimeInPowerZone {
		s[i] = float64(v) / 1000
	}
	return s
}

// GetMinAltitudeScaled returns MinAltitude
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: m
func (x *LapMsg) GetMinAltitudeScaled() float64 {
	if x.MinAltitude == 0xFFFF {
		return math.NaN()
	}
	return float64(x.MinAltitude)/5 - 500
}

// GetAvgVerticalOscillationScaled returns AvgVerticalOscillation
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: mm
func (x *LapMsg) GetAvgVerticalOscillationScaled() float64 {
	if x.AvgVerticalOscillation == 0xFFFF {
		return math.NaN()
	}
	return float64(x.AvgVerticalOscillation) / 10
}

// GetAvgStanceTimePercentScaled returns AvgStanceTimePercent
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: percent
func (x *LapMsg) GetAvgStanceTimePercentScaled() float64 {
	if x.AvgStanceTimePercent == 0xFFFF {
		return math.NaN()
	}
	return float64(x.AvgStanceTimePercent) / 100
}

// GetAvgStanceTimeScaled returns AvgStanceTime
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: ms
func (x *LapMsg) GetAvgStanceTimeScaled() float64 {
	if x.AvgStanceTime == 0xFFFF {
		return math.NaN()
	}
	return float64(x.AvgStanceTime) / 10
}

// GetAvgFractionalCadenceScaled returns AvgFractionalCadence
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: rpm
func (x *LapMsg) GetAvgFractionalCadenceScaled() float64 {
	if x.AvgFractionalCadence == 0xFF {
		return math.NaN()
	}
	return float64(x.AvgFractionalCadence) / 128
}

// GetMaxFractionalCadenceScaled returns MaxFractionalCadence
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: rpm
func (x *LapMsg) GetMaxFractionalCadenceScaled() float64 {
	if x.MaxFractionalCadence == 0xFF {
		return math.NaN()
	}
	return float64(x.MaxFractionalCadence) / 128
}

// GetTotalFractionalCyclesScaled returns TotalFractionalCycles
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: cycles
func (x *LapMsg) GetTotalFractionalCyclesScaled() float64 {
	if x.TotalFractionalCycles == 0xFF {
		return math.NaN()
	}
	return float64(x.TotalFractionalCycles) / 128
}

// GetAvgTotalHemoglobinConcScaled returns AvgTotalHemoglobinConc
// as a slice with scale and any offset applied to every element.
// Units: g/dL
func (x *LapMsg) GetAvgTotalHemoglobinConcScaled() []float64 {
	if len(x.AvgTotalHemoglobinConc) == 0 {
		return nil
	}
	s := make([]float64, len(x.AvgTotalHemoglobinConc))
	for i, v := range x.AvgTotalHemoglobinConc {
		s[i] = float64(v) / 100
	}
	return s
}

// GetMinTotalHemoglobinConcScaled returns MinTotalHemoglobinConc
// as a slice with scale and any offset applied to every element.
// Units: g/dL
func (x *LapMsg) GetMinTotalHemoglobinConcScaled() []float64 {
	if len(x.MinTotalHemoglobinConc) == 0 {
		return nil
	}
	s := make([]float64, len(x.MinTotalHemoglobinConc))
	for i, v := range x.MinTotalHemoglobinConc {
		s[i] = float64(v) / 100
	}
	return s
}

// GetMaxTotalHemoglobinConcScaled returns MaxTotalHemoglobinConc
// as a slice with scale and any offset applied to every element.
// Units: g/dL
func (x *LapMsg) GetMaxTotalHemoglobinConcScaled() []float64 {
	if len(x.MaxTotalHemoglobinConc) == 0 {
		return nil
	}
	s := make([]float64, len(x.MaxTotalHemoglobinConc))
	for i, v := range x.MaxTotalHemoglobinConc {
		s[i] = float64(v) / 100
	}
	return s
}

// GetAvgSaturatedHemoglobinPercentScaled returns AvgSaturatedHemoglobinPercent
// as a slice with scale and any offset applied to every element.
// Units: %
func (x *LapMsg) GetAvgSaturatedHemoglobinPercentScaled() []float64 {
	if len(x.AvgSaturatedHemoglobinPercent) == 0 {
		return nil
	}
	s := make([]float64, len(x.AvgSaturatedHemoglobinPercent))
	for i, v := range x.AvgSaturatedHemoglobinPercent {
		s[i] = float64(v) / 10
	}
	return s
}

// GetMinSaturatedHemoglobinPercentScaled returns MinSaturatedHemoglobinPercent
// as a slice with scale and any offset applied to every element.
// Units: %
func (x *LapMsg) GetMinSaturatedHemoglobinPercentScaled() []float64 {
	if len(x.MinSaturatedHemoglobinPercent) == 0 {
		return nil
	}
	s := make([]float64, len(x.MinSaturatedHemoglobinPercent))
	for i, v := range x.MinSaturatedHemoglobinPercent {
		s[i] = float64(v) / 10
	}
	return s
}

// GetMaxSaturatedHemoglobinPercentScaled returns MaxSaturatedHemoglobinPercent
// as a slice with scale and any offset applied to every element.
// Units: %
func (x *LapMsg) GetMaxSaturatedHemoglobinPercentScaled() []float64 {
	if len(x.MaxSaturatedHemoglobinPercent) == 0 {
		return nil
	}
	s := make([]float64, len(x.MaxSaturatedHemoglobinPercent))
	for i, v := range x.MaxSaturatedHemoglobinPercent {
		s[i] = float64(v) / 10
	}
	return s
}

// GetEnhancedAvgSpeedScaled returns EnhancedAvgSpeed
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: m/s
func (x *LapMsg) GetEnhancedAvgSpeedScaled() float64 {
	if x.EnhancedAvgSpeed == 0xFFFFFFFF {
		return math.NaN()
	}
	return float64(x.EnhancedAvgSpeed) / 1000
}

// GetEnhancedMaxSpeedScaled returns EnhancedMaxSpeed
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: m/s
func (x *LapMsg) GetEnhancedMaxSpeedScaled() float64 {
	if x.EnhancedMaxSpeed == 0xFFFFFFFF {
		return math.NaN()
	}
	return float64(x.EnhancedMaxSpeed) / 1000
}

// GetEnhancedAvgAltitudeScaled returns EnhancedAvgAltitude
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: m
func (x *LapMsg) GetEnhancedAvgAltitudeScaled() float64 {
	if x.EnhancedAvgAltitude == 0xFFFFFFFF {
		return math.NaN()
	}
	return float64(x.EnhancedAvgAltitude)/5 - 500
}

// GetEnhancedMinAltitudeScaled returns EnhancedMinAltitude
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: m
func (x *LapMsg) GetEnhancedMinAltitudeScaled() float64 {
	if x.EnhancedMinAltitude == 0xFFFFFFFF {
		return math.NaN()
	}
	return float64(x.EnhancedMinAltitude)/5 - 500
}

// GetEnhancedMaxAltitudeScaled returns EnhancedMaxAltitude
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: m
func (x *LapMsg) GetEnhancedMaxAltitudeScaled() float64 {
	if x.EnhancedMaxAltitude == 0xFFFFFFFF {
		return math.NaN()
	}
	return float64(x.EnhancedMaxAltitude)/5 - 500
}

// GetTotalCycles returns the appropriate TotalCycles
// subfield if a matching reference field/value combination is found.
// If none of the reference field/value combinations are true
// then the main field is returned.
func (x *LapMsg) GetTotalCycles() interface{} {
	switch x.Sport {
	case SportRunning, SportWalking:
		return uint32(x.TotalCycles)
	default:
		return x.TotalCycles
	}
}

// GetAvgCadence returns the appropriate AvgCadence
// subfield if a matching reference field/value combination is found.
// If none of the reference field/value combinations are true
// then the main field is returned.
func (x *LapMsg) GetAvgCadence() interface{} {
	switch x.Sport {
	case SportRunning:
		return uint8(x.AvgCadence)
	default:
		return x.AvgCadence
	}
}

// GetMaxCadence returns the appropriate MaxCadence
// subfield if a matching reference field/value combination is found.
// If none of the reference field/value combinations are true
// then the main field is returned.
func (x *LapMsg) GetMaxCadence() interface{} {
	switch x.Sport {
	case SportRunning:
		return uint8(x.MaxCadence)
	default:
		return x.MaxCadence
	}
}

func (x *LapMsg) expandComponents() {
	if x.AvgSpeed != 0xFFFF {
		x.EnhancedAvgSpeed = uint32(
			(x.AvgSpeed >> 0) & ((1 << 16) - 1),
		)
	}
	if x.MaxSpeed != 0xFFFF {
		x.EnhancedMaxSpeed = uint32(
			(x.MaxSpeed >> 0) & ((1 << 16) - 1),
		)
	}
	if x.AvgAltitude != 0xFFFF {
		x.EnhancedAvgAltitude = uint32(
			(x.AvgAltitude >> 0) & ((1 << 16) - 1),
		)
	}
	if x.MaxAltitude != 0xFFFF {
		x.EnhancedMaxAltitude = uint32(
			(x.MaxAltitude >> 0) & ((1 << 16) - 1),
		)
	}
	if x.MinAltitude != 0xFFFF {
		x.EnhancedMinAltitude = uint32(
			(x.MinAltitude >> 0) & ((1 << 16) - 1),
		)
	}
}

// LengthMsg represents the length FIT message type.
type LengthMsg struct {
	MessageIndex       MessageIndex
	Timestamp          time.Time
	Event              Event
	EventType          EventType
	StartTime          time.Time
	TotalElapsedTime   uint32
	TotalTimerTime     uint32
	TotalStrokes       uint16
	AvgSpeed           uint16
	SwimStroke         SwimStroke
	AvgSwimmingCadence uint8
	EventGroup         uint8
	TotalCalories      uint16
	LengthType         LengthType
	PlayerScore        uint16
	OpponentScore      uint16
	StrokeCount        []uint16 // stroke_type enum used as the index
	ZoneCount          []uint16 // zone number used as the index
}

// GetTotalElapsedTimeScaled returns TotalElapsedTime
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: s
func (x *LengthMsg) GetTotalElapsedTimeScaled() float64 {
	if x.TotalElapsedTime == 0xFFFFFFFF {
		return math.NaN()
	}
	return float64(x.TotalElapsedTime) / 1000
}

// GetTotalTimerTimeScaled returns TotalTimerTime
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: s
func (x *LengthMsg) GetTotalTimerTimeScaled() float64 {
	if x.TotalTimerTime == 0xFFFFFFFF {
		return math.NaN()
	}
	return float64(x.TotalTimerTime) / 1000
}

// GetAvgSpeedScaled returns AvgSpeed
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: m/s
func (x *LengthMsg) GetAvgSpeedScaled() float64 {
	if x.AvgSpeed == 0xFFFF {
		return math.NaN()
	}
	return float64(x.AvgSpeed) / 1000
}

// RecordMsg represents the record FIT message type.
type RecordMsg struct {
	Timestamp                     time.Time
	PositionLat                   Latitude
	PositionLong                  Longitude
	Altitude                      uint16
	HeartRate                     uint8
	Cadence                       uint8
	Distance                      uint32
	Speed                         uint16
	Power                         uint16
	CompressedSpeedDistance       []byte
	Grade                         int16
	Resistance                    uint8 // Relative. 0 is none  254 is Max.
	TimeFromCourse                int32
	CycleLength                   uint8
	Temperature                   int8
	Speed1s                       []uint8 // Speed at 1s intervals.  Timestamp field indicates time of last array element.
	Cycles                        uint8
	TotalCycles                   uint32
	CompressedAccumulatedPower    uint16
	AccumulatedPower              uint32
	LeftRightBalance              LeftRightBalance
	GpsAccuracy                   uint8
	VerticalSpeed                 int16
	Calories                      uint16
	VerticalOscillation           uint16
	StanceTimePercent             uint16
	StanceTime                    uint16
	ActivityType                  ActivityType
	LeftTorqueEffectiveness       uint8
	RightTorqueEffectiveness      uint8
	LeftPedalSmoothness           uint8
	RightPedalSmoothness          uint8
	CombinedPedalSmoothness       uint8
	Time128                       uint8
	StrokeType                    StrokeType
	Zone                          uint8
	BallSpeed                     uint16
	Cadence256                    uint16 // Log cadence and fractional cadence for backwards compatability
	FractionalCadence             uint8
	TotalHemoglobinConc           uint16 // Total saturated and unsaturated hemoglobin
	TotalHemoglobinConcMin        uint16 // Min saturated and unsaturated hemoglobin
	TotalHemoglobinConcMax        uint16 // Max saturated and unsaturated hemoglobin
	SaturatedHemoglobinPercent    uint16 // Percentage of hemoglobin saturated with oxygen
	SaturatedHemoglobinPercentMin uint16 // Min percentage of hemoglobin saturated with oxygen
	SaturatedHemoglobinPercentMax uint16 // Max percentage of hemoglobin saturated with oxygen
	DeviceIndex                   DeviceIndex
	EnhancedSpeed                 uint32
	EnhancedAltitude              uint32
}

// GetAltitudeScaled returns Altitude
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: m
func (x *RecordMsg) GetAltitudeScaled() float64 {
	if x.Altitude == 0xFFFF {
		return math.NaN()
	}
	return float64(x.Altitude)/5 - 500
}

// GetDistanceScaled returns Distance
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: m
func (x *RecordMsg) GetDistanceScaled() float64 {
	if x.Distance == 0xFFFFFFFF {
		return math.NaN()
	}
	return float64(x.Distance) / 100
}

// GetSpeedScaled returns Speed
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: m/s
func (x *RecordMsg) GetSpeedScaled() float64 {
	if x.Speed == 0xFFFF {
		return math.NaN()
	}
	return float64(x.Speed) / 1000
}

// GetGradeScaled returns Grade
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: %
func (x *RecordMsg) GetGradeScaled() float64 {
	if x.Grade == 0x7FFF {
		return math.NaN()
	}
	return float64(x.Grade) / 100
}

// GetTimeFromCourseScaled returns TimeFromCourse
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: s
func (x *RecordMsg) GetTimeFromCourseScaled() float64 {
	if x.TimeFromCourse == 0x7FFFFFFF {
		return math.NaN()
	}
	return float64(x.TimeFromCourse) / 1000
}

// GetCycleLengthScaled returns CycleLength
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: m
func (x *RecordMsg) GetCycleLengthScaled() float64 {
	if x.CycleLength == 0xFF {
		return math.NaN()
	}
	return float64(x.CycleLength) / 100
}

// GetSpeed1sScaled returns Speed1s
// as a slice with scale and any offset applied to every element.
// Units: m/s
func (x *RecordMsg) GetSpeed1sScaled() []float64 {
	if len(x.Speed1s) == 0 {
		return nil
	}
	s := make([]float64, len(x.Speed1s))
	for i, v := range x.Speed1s {
		s[i] = float64(v) / 16
	}
	return s
}

// GetVerticalSpeedScaled returns VerticalSpeed
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: m/s
func (x *RecordMsg) GetVerticalSpeedScaled() float64 {
	if x.VerticalSpeed == 0x7FFF {
		return math.NaN()
	}
	return float64(x.VerticalSpeed) / 1000
}

// GetVerticalOscillationScaled returns VerticalOscillation
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: mm
func (x *RecordMsg) GetVerticalOscillationScaled() float64 {
	if x.VerticalOscillation == 0xFFFF {
		return math.NaN()
	}
	return float64(x.VerticalOscillation) / 10
}

// GetStanceTimePercentScaled returns StanceTimePercent
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: percent
func (x *RecordMsg) GetStanceTimePercentScaled() float64 {
	if x.StanceTimePercent == 0xFFFF {
		return math.NaN()
	}
	return float64(x.StanceTimePercent) / 100
}

// GetStanceTimeScaled returns StanceTime
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: ms
func (x *RecordMsg) GetStanceTimeScaled() float64 {
	if x.StanceTime == 0xFFFF {
		return math.NaN()
	}
	return float64(x.StanceTime) / 10
}

// GetLeftTorqueEffectivenessScaled returns LeftTorqueEffectiveness
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: percent
func (x *RecordMsg) GetLeftTorqueEffectivenessScaled() float64 {
	if x.LeftTorqueEffectiveness == 0xFF {
		return math.NaN()
	}
	return float64(x.LeftTorqueEffectiveness) / 2
}

// GetRightTorqueEffectivenessScaled returns RightTorqueEffectiveness
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: percent
func (x *RecordMsg) GetRightTorqueEffectivenessScaled() float64 {
	if x.RightTorqueEffectiveness == 0xFF {
		return math.NaN()
	}
	return float64(x.RightTorqueEffectiveness) / 2
}

// GetLeftPedalSmoothnessScaled returns LeftPedalSmoothness
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: percent
func (x *RecordMsg) GetLeftPedalSmoothnessScaled() float64 {
	if x.LeftPedalSmoothness == 0xFF {
		return math.NaN()
	}
	return float64(x.LeftPedalSmoothness) / 2
}

// GetRightPedalSmoothnessScaled returns RightPedalSmoothness
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: percent
func (x *RecordMsg) GetRightPedalSmoothnessScaled() float64 {
	if x.RightPedalSmoothness == 0xFF {
		return math.NaN()
	}
	return float64(x.RightPedalSmoothness) / 2
}

// GetCombinedPedalSmoothnessScaled returns CombinedPedalSmoothness
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: percent
func (x *RecordMsg) GetCombinedPedalSmoothnessScaled() float64 {
	if x.CombinedPedalSmoothness == 0xFF {
		return math.NaN()
	}
	return float64(x.CombinedPedalSmoothness) / 2
}

// GetTime128Scaled returns Time128
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: s
func (x *RecordMsg) GetTime128Scaled() float64 {
	if x.Time128 == 0xFF {
		return math.NaN()
	}
	return float64(x.Time128) / 128
}

// GetBallSpeedScaled returns BallSpeed
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: m/s
func (x *RecordMsg) GetBallSpeedScaled() float64 {
	if x.BallSpeed == 0xFFFF {
		return math.NaN()
	}
	return float64(x.BallSpeed) / 100
}

// GetCadence256Scaled returns Cadence256
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: rpm
func (x *RecordMsg) GetCadence256Scaled() float64 {
	if x.Cadence256 == 0xFFFF {
		return math.NaN()
	}
	return float64(x.Cadence256) / 256
}

// GetFractionalCadenceScaled returns FractionalCadence
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: rpm
func (x *RecordMsg) GetFractionalCadenceScaled() float64 {
	if x.FractionalCadence == 0xFF {
		return math.NaN()
	}
	return float64(x.FractionalCadence) / 128
}

// GetTotalHemoglobinConcScaled returns TotalHemoglobinConc
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: g/dL
func (x *RecordMsg) GetTotalHemoglobinConcScaled() float64 {
	if x.TotalHemoglobinConc == 0xFFFF {
		return math.NaN()
	}
	return float64(x.TotalHemoglobinConc) / 100
}

// GetTotalHemoglobinConcMinScaled returns TotalHemoglobinConcMin
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: g/dL
func (x *RecordMsg) GetTotalHemoglobinConcMinScaled() float64 {
	if x.TotalHemoglobinConcMin == 0xFFFF {
		return math.NaN()
	}
	return float64(x.TotalHemoglobinConcMin) / 100
}

// GetTotalHemoglobinConcMaxScaled returns TotalHemoglobinConcMax
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: g/dL
func (x *RecordMsg) GetTotalHemoglobinConcMaxScaled() float64 {
	if x.TotalHemoglobinConcMax == 0xFFFF {
		return math.NaN()
	}
	return float64(x.TotalHemoglobinConcMax) / 100
}

// GetSaturatedHemoglobinPercentScaled returns SaturatedHemoglobinPercent
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: %
func (x *RecordMsg) GetSaturatedHemoglobinPercentScaled() float64 {
	if x.SaturatedHemoglobinPercent == 0xFFFF {
		return math.NaN()
	}
	return float64(x.SaturatedHemoglobinPercent) / 10
}

// GetSaturatedHemoglobinPercentMinScaled returns SaturatedHemoglobinPercentMin
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: %
func (x *RecordMsg) GetSaturatedHemoglobinPercentMinScaled() float64 {
	if x.SaturatedHemoglobinPercentMin == 0xFFFF {
		return math.NaN()
	}
	return float64(x.SaturatedHemoglobinPercentMin) / 10
}

// GetSaturatedHemoglobinPercentMaxScaled returns SaturatedHemoglobinPercentMax
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: %
func (x *RecordMsg) GetSaturatedHemoglobinPercentMaxScaled() float64 {
	if x.SaturatedHemoglobinPercentMax == 0xFFFF {
		return math.NaN()
	}
	return float64(x.SaturatedHemoglobinPercentMax) / 10
}

// GetEnhancedSpeedScaled returns EnhancedSpeed
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: m/s
func (x *RecordMsg) GetEnhancedSpeedScaled() float64 {
	if x.EnhancedSpeed == 0xFFFFFFFF {
		return math.NaN()
	}
	return float64(x.EnhancedSpeed) / 1000
}

// GetEnhancedAltitudeScaled returns EnhancedAltitude
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: m
func (x *RecordMsg) GetEnhancedAltitudeScaled() float64 {
	if x.EnhancedAltitude == 0xFFFFFFFF {
		return math.NaN()
	}
	return float64(x.EnhancedAltitude)/5 - 500
}

// GetSpeedFromCompressedSpeedDistance returns
// Speed with the scale and offset defined by the "Speed"
// component in the CompressedSpeedDistance field. NaN is
// if the field has an invalid value (i.e. has not been set).
func (x *RecordMsg) GetSpeedFromCompressedSpeedDistance() float64 {
	if x.Speed == 0xFFFF {
		return math.NaN()
	}
	return float64(x.Speed) / 100
}

// GetDistanceFromCompressedSpeedDistance returns
// Distance with the scale and offset defined by the "Distance"
// component in the CompressedSpeedDistance field. NaN is
// if the field has an invalid value (i.e. has not been set).
func (x *RecordMsg) GetDistanceFromCompressedSpeedDistance() float64 {
	if x.Distance == 0xFFFFFFFF {
		return math.NaN()
	}
	return float64(x.Distance) / 16
}

func (x *RecordMsg) expandComponents() {
	if x.Altitude != 0xFFFF {
		x.EnhancedAltitude = uint32(
			(x.Altitude >> 0) & ((1 << 16) - 1),
		)
	}
	if x.Speed != 0xFFFF {
		x.EnhancedSpeed = uint32(
			(x.Speed >> 0) & ((1 << 16) - 1),
		)
	}
	expand := false
	if len(x.CompressedSpeedDistance) == 3 {
		for _, v := range x.CompressedSpeedDistance {
			if v != 0xFF {
				expand = true
				break
			}
		}
	}
	if expand {
		x.Speed = uint16(x.CompressedSpeedDistance[0]) | uint16(x.CompressedSpeedDistance[1]&0x0F)<<8
		if accumuDistance == nil {
			accumuDistance = uint32NewAccumulator(12)
		}
		x.Distance = accumuDistance.accumulate(
			uint32(x.CompressedSpeedDistance[1]>>4) | uint32(x.CompressedSpeedDistance[2]<<4),
		)
	}
	if x.Cycles != 0xFF {
		if accumuTotalCycles == nil {
			accumuTotalCycles = new(uint32Accumulator)
		}
		x.TotalCycles = accumuTotalCycles.accumulate(
			uint32(
				(x.Cycles >> 0) & ((1 << 8) - 1),
			),
		)
	}
	if x.CompressedAccumulatedPower != 0xFFFF {
		if accumuAccumulatedPower == nil {
			accumuAccumulatedPower = new(uint32Accumulator)
		}
		x.AccumulatedPower = accumuAccumulatedPower.accumulate(
			uint32(
				(x.CompressedAccumulatedPower >> 0) & ((1 << 16) - 1),
			),
		)
	}
}

// EventMsg represents the event FIT message type.
type EventMsg struct {
	Timestamp     time.Time
	Event         Event
	EventType     EventType
	Data16        uint16
	Data          uint32
	EventGroup    uint8
	Score         uint16 // Do not populate directly.  Autogenerated by decoder for sport_point subfield components
	OpponentScore uint16 // Do not populate directly.  Autogenerated by decoder for sport_point subfield components
	FrontGearNum  uint8  // Do not populate directly.  Autogenerated by decoder for gear_change subfield components.  Front gear number. 1 is innermost.
	FrontGear     uint8  // Do not populate directly.  Autogenerated by decoder for gear_change subfield components.  Number of front teeth.
	RearGearNum   uint8  // Do not populate directly.  Autogenerated by decoder for gear_change subfield components.  Rear gear number. 1 is innermost.
	RearGear      uint8  // Do not populate directly.  Autogenerated by decoder for gear_change subfield components.  Number of rear teeth.
}

// GetData returns the appropriate Data
// subfield if a matching reference field/value combination is found.
// If none of the reference field/value combinations are true
// then the main field is returned.
func (x *EventMsg) GetData() interface{} {
	switch x.Event {
	case EventTimer:
		return TimerTrigger(x.Data)
	case EventCoursePoint:
		return MessageIndex(x.Data)
	case EventBattery:
		return float64(x.Data) / 1000
	case EventVirtualPartnerPace:
		return float64(x.Data) / 1000
	case EventHrHighAlert:
		return uint8(x.Data)
	case EventHrLowAlert:
		return uint8(x.Data)
	case EventSpeedHighAlert:
		return float64(x.Data) / 1000
	case EventSpeedLowAlert:
		return float64(x.Data) / 1000
	case EventCadHighAlert:
		return uint16(x.Data)
	case EventCadLowAlert:
		return uint16(x.Data)
	case EventPowerHighAlert:
		return uint16(x.Data)
	case EventPowerLowAlert:
		return uint16(x.Data)
	case EventTimeDurationAlert:
		return float64(x.Data) / 1000
	case EventDistanceDurationAlert:
		return float64(x.Data) / 100
	case EventCalorieDurationAlert:
		return uint32(x.Data)
	case EventFitnessEquipment:
		return FitnessEquipmentState(x.Data)
	case EventSportPoint:
		return uint32(x.Data)
	case EventFrontGearChange, EventRearGearChange:
		return uint32(x.Data)
	default:
		return x.Data
	}
}

func (x *EventMsg) expandComponents() {
	if x.Data16 != 0xFFFF {
		x.Data = uint32(
			(x.Data16 >> 0) & ((1 << 16) - 1),
		)
	}
	if x.Data != 0xFFFFFFFF {
		switch x.Event {
		case EventSportPoint:
			x.Score = uint16(
				(x.Data >> 0) & ((1 << 16) - 1),
			)
			x.OpponentScore = uint16(
				(x.Data >> 16) & ((1 << 16) - 1),
			)
		case EventFrontGearChange, EventRearGearChange:
			x.RearGearNum = uint8(
				(x.Data >> 0) & ((1 << 8) - 1),
			)
			x.RearGear = uint8(
				(x.Data >> 8) & ((1 << 8) - 1),
			)
			x.FrontGearNum = uint8(
				(x.Data >> 16) & ((1 << 8) - 1),
			)
			x.FrontGear = uint8(
				(x.Data >> 24) & ((1 << 8) - 1),
			)
		}
	}
}

// DeviceInfoMsg represents the device_info FIT message type.
type DeviceInfoMsg struct {
	Timestamp           time.Time
	DeviceIndex         DeviceIndex
	DeviceType          uint8
	Manufacturer        Manufacturer
	SerialNumber        uint32
	Product             uint16
	SoftwareVersion     uint16
	HardwareVersion     uint8
	CumOperatingTime    uint32 // Reset by new battery or charge.
	BatteryVoltage      uint16
	BatteryStatus       BatteryStatus
	SensorPosition      BodyLocation // Indicates the location of the sensor
	Descriptor          string       // Used to describe the sensor or location
	AntTransmissionType uint8
	AntDeviceNumber     uint16
	AntNetwork          AntNetwork
	SourceType          SourceType
	ProductName         string // Optional free form string to indicate the devices name or model
}

// GetSoftwareVersionScaled returns SoftwareVersion
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
func (x *DeviceInfoMsg) GetSoftwareVersionScaled() float64 {
	if x.SoftwareVersion == 0xFFFF {
		return math.NaN()
	}
	return float64(x.SoftwareVersion) / 100
}

// GetBatteryVoltageScaled returns BatteryVoltage
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: V
func (x *DeviceInfoMsg) GetBatteryVoltageScaled() float64 {
	if x.BatteryVoltage == 0xFFFF {
		return math.NaN()
	}
	return float64(x.BatteryVoltage) / 256
}

// GetDeviceType returns the appropriate DeviceType
// subfield if a matching reference field/value combination is found.
// If none of the reference field/value combinations are true
// then the main field is returned.
func (x *DeviceInfoMsg) GetDeviceType() interface{} {
	switch x.SourceType {
	case SourceTypeAntplus:
		return AntplusDeviceType(x.DeviceType)
	case SourceTypeAnt:
		return uint8(x.DeviceType)
	default:
		return x.DeviceType
	}
}

// GetProduct returns the appropriate Product
// subfield if a matching reference field/value combination is found.
// If none of the reference field/value combinations are true
// then the main field is returned.
func (x *DeviceInfoMsg) GetProduct() interface{} {
	switch x.Manufacturer {
	case ManufacturerGarmin, ManufacturerDynastream, ManufacturerDynastreamOem:
		return GarminProduct(x.Product)
	default:
		return x.Product
	}
}

// TrainingFileMsg represents the training_file FIT message type.
type TrainingFileMsg struct {
	Timestamp    time.Time
	Type         File
	Manufacturer Manufacturer
	Product      uint16
	SerialNumber uint32
	TimeCreated  time.Time
}

// GetProduct returns the appropriate Product
// subfield if a matching reference field/value combination is found.
// If none of the reference field/value combinations are true
// then the main field is returned.
func (x *TrainingFileMsg) GetProduct() interface{} {
	switch x.Manufacturer {
	case ManufacturerGarmin, ManufacturerDynastream, ManufacturerDynastreamOem:
		return GarminProduct(x.Product)
	default:
		return x.Product
	}
}

// HrvMsg represents the hrv FIT message type.
type HrvMsg struct {
	Time []uint16 // Time between beats
}

// GetTimeScaled returns Time
// as a slice with scale and any offset applied to every element.
// Units: s
func (x *HrvMsg) GetTimeScaled() []float64 {
	if len(x.Time) == 0 {
		return nil
	}
	s := make([]float64, len(x.Time))
	for i, v := range x.Time {
		s[i] = float64(v) / 1000
	}
	return s
}

// CameraEventMsg represents the camera_event FIT message type.
type CameraEventMsg struct {
}

// GyroscopeDataMsg represents the gyroscope_data FIT message type.
type GyroscopeDataMsg struct {
}

// AccelerometerDataMsg represents the accelerometer_data FIT message type.
type AccelerometerDataMsg struct {
}

// ThreeDSensorCalibrationMsg represents the three_d_sensor_calibration FIT message type.
type ThreeDSensorCalibrationMsg struct {
}

// VideoFrameMsg represents the video_frame FIT message type.
type VideoFrameMsg struct {
}

// ObdiiDataMsg represents the obdii_data FIT message type.
type ObdiiDataMsg struct {
}

// NmeaSentenceMsg represents the nmea_sentence FIT message type.
type NmeaSentenceMsg struct {
	Timestamp   time.Time // Timestamp message was output
	TimestampMs uint16    // Fractional part of timestamp, added to timestamp
	Sentence    string    // NMEA sentence
}

// AviationAttitudeMsg represents the aviation_attitude FIT message type.
type AviationAttitudeMsg struct {
	Timestamp             time.Time // Timestamp message was output
	TimestampMs           uint16    // Fractional part of timestamp, added to timestamp
	SystemTime            []uint32  // System time associated with sample expressed in ms.
	Pitch                 []int16   // Range -PI/2 to +PI/2
	Roll                  []int16   // Range -PI to +PI
	AccelLateral          []int16   // Range -78.4 to +78.4 (-8 Gs to 8 Gs)
	AccelNormal           []int16   // Range -78.4 to +78.4 (-8 Gs to 8 Gs)
	TurnRate              []int16   // Range -8.727 to +8.727 (-500 degs/sec to +500 degs/sec)
	Stage                 []AttitudeStage
	AttitudeStageComplete []uint8  // The percent complete of the current attitude stage.  Set to 0 for attitude stages 0, 1 and 2 and to 100 for attitude stage 3 by AHRS modules that do not support it.  Range - 100
	Track                 []uint16 // Track Angle/Heading Range 0 - 2pi
	Validity              []AttitudeValidity
}

// GetPitchScaled returns Pitch
// as a slice with scale and any offset applied to every element.
// Units: radians
func (x *AviationAttitudeMsg) GetPitchScaled() []float64 {
	if len(x.Pitch) == 0 {
		return nil
	}
	s := make([]float64, len(x.Pitch))
	for i, v := range x.Pitch {
		s[i] = float64(v) / 10430.379999999999
	}
	return s
}

// GetRollScaled returns Roll
// as a slice with scale and any offset applied to every element.
// Units: radians
func (x *AviationAttitudeMsg) GetRollScaled() []float64 {
	if len(x.Roll) == 0 {
		return nil
	}
	s := make([]float64, len(x.Roll))
	for i, v := range x.Roll {
		s[i] = float64(v) / 10430.379999999999
	}
	return s
}

// GetAccelLateralScaled returns AccelLateral
// as a slice with scale and any offset applied to every element.
// Units: m/s^2
func (x *AviationAttitudeMsg) GetAccelLateralScaled() []float64 {
	if len(x.AccelLateral) == 0 {
		return nil
	}
	s := make([]float64, len(x.AccelLateral))
	for i, v := range x.AccelLateral {
		s[i] = float64(v) / 100
	}
	return s
}

// GetAccelNormalScaled returns AccelNormal
// as a slice with scale and any offset applied to every element.
// Units: m/s^2
func (x *AviationAttitudeMsg) GetAccelNormalScaled() []float64 {
	if len(x.AccelNormal) == 0 {
		return nil
	}
	s := make([]float64, len(x.AccelNormal))
	for i, v := range x.AccelNormal {
		s[i] = float64(v) / 100
	}
	return s
}

// GetTurnRateScaled returns TurnRate
// as a slice with scale and any offset applied to every element.
// Units: radians/second
func (x *AviationAttitudeMsg) GetTurnRateScaled() []float64 {
	if len(x.TurnRate) == 0 {
		return nil
	}
	s := make([]float64, len(x.TurnRate))
	for i, v := range x.TurnRate {
		s[i] = float64(v) / 1024
	}
	return s
}

// GetTrackScaled returns Track
// as a slice with scale and any offset applied to every element.
// Units: radians
func (x *AviationAttitudeMsg) GetTrackScaled() []float64 {
	if len(x.Track) == 0 {
		return nil
	}
	s := make([]float64, len(x.Track))
	for i, v := range x.Track {
		s[i] = float64(v) / 10430.379999999999
	}
	return s
}

// VideoMsg represents the video FIT message type.
type VideoMsg struct {
}

// VideoTitleMsg represents the video_title FIT message type.
type VideoTitleMsg struct {
	MessageIndex MessageIndex // Long titles will be split into multiple parts
	MessageCount uint16       // Total number of title parts
	Text         string
}

// VideoDescriptionMsg represents the video_description FIT message type.
type VideoDescriptionMsg struct {
	MessageIndex MessageIndex // Long descriptions will be split into multiple parts
	MessageCount uint16       // Total number of description parts
	Text         string
}

// VideoClipMsg represents the video_clip FIT message type.
type VideoClipMsg struct {
}

// CourseMsg represents the course FIT message type.
type CourseMsg struct {
	Sport        Sport
	Name         string
	Capabilities CourseCapabilities
}

// CoursePointMsg represents the course_point FIT message type.
type CoursePointMsg struct {
	MessageIndex MessageIndex
	Timestamp    time.Time
	PositionLat  Latitude
	PositionLong Longitude
	Distance     uint32
	Type         CoursePoint
	Name         string
	Favorite     Bool
}

// GetDistanceScaled returns Distance
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: m
func (x *CoursePointMsg) GetDistanceScaled() float64 {
	if x.Distance == 0xFFFFFFFF {
		return math.NaN()
	}
	return float64(x.Distance) / 100
}

// SegmentIdMsg represents the segment_id FIT message type.
type SegmentIdMsg struct {
	Name                  string               // Friendly name assigned to segment
	Uuid                  string               // UUID of the segment
	Sport                 Sport                // Sport associated with the segment
	Enabled               Bool                 // Segment enabled for evaluation
	UserProfilePrimaryKey uint32               // Primary key of the user that created the segment
	DeviceId              uint32               // ID of the device that created the segment
	DefaultRaceLeader     uint8                // Index for the Leader Board entry selected as the default race participant
	DeleteStatus          SegmentDeleteStatus  // Indicates if any segments should be deleted
	SelectionType         SegmentSelectionType // Indicates how the segment was selected to be sent to the device
}

// SegmentLeaderboardEntryMsg represents the segment_leaderboard_entry FIT message type.
type SegmentLeaderboardEntryMsg struct {
	MessageIndex    MessageIndex
	Name            string                 // Friendly name assigned to leader
	Type            SegmentLeaderboardType // Leader classification
	GroupPrimaryKey uint32                 // Primary user ID of this leader
	ActivityId      uint32                 // ID of the activity associated with this leader time
	SegmentTime     uint32                 // Segment Time (includes pauses)
}

// GetSegmentTimeScaled returns SegmentTime
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: s
func (x *SegmentLeaderboardEntryMsg) GetSegmentTimeScaled() float64 {
	if x.SegmentTime == 0xFFFFFFFF {
		return math.NaN()
	}
	return float64(x.SegmentTime) / 1000
}

// SegmentPointMsg represents the segment_point FIT message type.
type SegmentPointMsg struct {
	MessageIndex MessageIndex
	PositionLat  Latitude
	PositionLong Longitude
	Distance     uint32   // Accumulated distance along the segment at the described point
	Altitude     uint16   // Accumulated altitude along the segment at the described point
	LeaderTime   []uint32 // Accumualted time each leader board member required to reach the described point. This value is zero for all leader board members at the starting point of the segment.
}

// GetDistanceScaled returns Distance
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: m
func (x *SegmentPointMsg) GetDistanceScaled() float64 {
	if x.Distance == 0xFFFFFFFF {
		return math.NaN()
	}
	return float64(x.Distance) / 100
}

// GetAltitudeScaled returns Altitude
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: m
func (x *SegmentPointMsg) GetAltitudeScaled() float64 {
	if x.Altitude == 0xFFFF {
		return math.NaN()
	}
	return float64(x.Altitude)/5 - 500
}

// GetLeaderTimeScaled returns LeaderTime
// as a slice with scale and any offset applied to every element.
// Units: s
func (x *SegmentPointMsg) GetLeaderTimeScaled() []float64 {
	if len(x.LeaderTime) == 0 {
		return nil
	}
	s := make([]float64, len(x.LeaderTime))
	for i, v := range x.LeaderTime {
		s[i] = float64(v) / 1000
	}
	return s
}

// SegmentLapMsg represents the segment_lap FIT message type.
type SegmentLapMsg struct {
	MessageIndex                MessageIndex
	Timestamp                   time.Time // Lap end time.
	Event                       Event
	EventType                   EventType
	StartTime                   time.Time
	StartPositionLat            Latitude
	StartPositionLong           Longitude
	EndPositionLat              Latitude
	EndPositionLong             Longitude
	TotalElapsedTime            uint32 // Time (includes pauses)
	TotalTimerTime              uint32 // Timer Time (excludes pauses)
	TotalDistance               uint32
	TotalCycles                 uint32
	TotalCalories               uint16
	TotalFatCalories            uint16 // If New Leaf
	AvgSpeed                    uint16
	MaxSpeed                    uint16
	AvgHeartRate                uint8
	MaxHeartRate                uint8
	AvgCadence                  uint8 // total_cycles / total_timer_time if non_zero_avg_cadence otherwise total_cycles / total_elapsed_time
	MaxCadence                  uint8
	AvgPower                    uint16 // total_power / total_timer_time if non_zero_avg_power otherwise total_power / total_elapsed_time
	MaxPower                    uint16
	TotalAscent                 uint16
	TotalDescent                uint16
	Sport                       Sport
	EventGroup                  uint8
	NecLat                      Latitude  // North east corner latitude.
	NecLong                     Longitude // North east corner longitude.
	SwcLat                      Latitude  // South west corner latitude.
	SwcLong                     Longitude // South west corner latitude.
	Name                        string
	NormalizedPower             uint16
	LeftRightBalance            LeftRightBalance100
	SubSport                    SubSport
	TotalWork                   uint32
	AvgAltitude                 uint16
	MaxAltitude                 uint16
	GpsAccuracy                 uint8
	AvgGrade                    int16
	AvgPosGrade                 int16
	AvgNegGrade                 int16
	MaxPosGrade                 int16
	MaxNegGrade                 int16
	AvgTemperature              int8
	MaxTemperature              int8
	TotalMovingTime             uint32
	AvgPosVerticalSpeed         int16
	AvgNegVerticalSpeed         int16
	MaxPosVerticalSpeed         int16
	MaxNegVerticalSpeed         int16
	TimeInHrZone                []uint32
	TimeInSpeedZone             []uint32
	TimeInCadenceZone           []uint32
	TimeInPowerZone             []uint32
	RepetitionNum               uint16
	MinAltitude                 uint16
	MinHeartRate                uint8
	ActiveTime                  uint32
	WktStepIndex                MessageIndex
	SportEvent                  SportEvent
	AvgLeftTorqueEffectiveness  uint8
	AvgRightTorqueEffectiveness uint8
	AvgLeftPedalSmoothness      uint8
	AvgRightPedalSmoothness     uint8
	AvgCombinedPedalSmoothness  uint8
	Status                      SegmentLapStatus
	Uuid                        string
	AvgFractionalCadence        uint8 // fractional part of the avg_cadence
	MaxFractionalCadence        uint8 // fractional part of the max_cadence
	TotalFractionalCycles       uint8 // fractional part of the total_cycles
	FrontGearShiftCount         uint16
	RearGearShiftCount          uint16
}

// GetTotalElapsedTimeScaled returns TotalElapsedTime
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: s
func (x *SegmentLapMsg) GetTotalElapsedTimeScaled() float64 {
	if x.TotalElapsedTime == 0xFFFFFFFF {
		return math.NaN()
	}
	return float64(x.TotalElapsedTime) / 1000
}

// GetTotalTimerTimeScaled returns TotalTimerTime
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: s
func (x *SegmentLapMsg) GetTotalTimerTimeScaled() float64 {
	if x.TotalTimerTime == 0xFFFFFFFF {
		return math.NaN()
	}
	return float64(x.TotalTimerTime) / 1000
}

// GetTotalDistanceScaled returns TotalDistance
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: m
func (x *SegmentLapMsg) GetTotalDistanceScaled() float64 {
	if x.TotalDistance == 0xFFFFFFFF {
		return math.NaN()
	}
	return float64(x.TotalDistance) / 100
}

// GetAvgSpeedScaled returns AvgSpeed
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: m/s
func (x *SegmentLapMsg) GetAvgSpeedScaled() float64 {
	if x.AvgSpeed == 0xFFFF {
		return math.NaN()
	}
	return float64(x.AvgSpeed) / 1000
}

// GetMaxSpeedScaled returns MaxSpeed
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: m/s
func (x *SegmentLapMsg) GetMaxSpeedScaled() float64 {
	if x.MaxSpeed == 0xFFFF {
		return math.NaN()
	}
	return float64(x.MaxSpeed) / 1000
}

// GetAvgAltitudeScaled returns AvgAltitude
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: m
func (x *SegmentLapMsg) GetAvgAltitudeScaled() float64 {
	if x.AvgAltitude == 0xFFFF {
		return math.NaN()
	}
	return float64(x.AvgAltitude)/5 - 500
}

// GetMaxAltitudeScaled returns MaxAltitude
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: m
func (x *SegmentLapMsg) GetMaxAltitudeScaled() float64 {
	if x.MaxAltitude == 0xFFFF {
		return math.NaN()
	}
	return float64(x.MaxAltitude)/5 - 500
}

// GetAvgGradeScaled returns AvgGrade
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: %
func (x *SegmentLapMsg) GetAvgGradeScaled() float64 {
	if x.AvgGrade == 0x7FFF {
		return math.NaN()
	}
	return float64(x.AvgGrade) / 100
}

// GetAvgPosGradeScaled returns AvgPosGrade
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: %
func (x *SegmentLapMsg) GetAvgPosGradeScaled() float64 {
	if x.AvgPosGrade == 0x7FFF {
		return math.NaN()
	}
	return float64(x.AvgPosGrade) / 100
}

// GetAvgNegGradeScaled returns AvgNegGrade
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: %
func (x *SegmentLapMsg) GetAvgNegGradeScaled() float64 {
	if x.AvgNegGrade == 0x7FFF {
		return math.NaN()
	}
	return float64(x.AvgNegGrade) / 100
}

// GetMaxPosGradeScaled returns MaxPosGrade
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: %
func (x *SegmentLapMsg) GetMaxPosGradeScaled() float64 {
	if x.MaxPosGrade == 0x7FFF {
		return math.NaN()
	}
	return float64(x.MaxPosGrade) / 100
}

// GetMaxNegGradeScaled returns MaxNegGrade
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: %
func (x *SegmentLapMsg) GetMaxNegGradeScaled() float64 {
	if x.MaxNegGrade == 0x7FFF {
		return math.NaN()
	}
	return float64(x.MaxNegGrade) / 100
}

// GetTotalMovingTimeScaled returns TotalMovingTime
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: s
func (x *SegmentLapMsg) GetTotalMovingTimeScaled() float64 {
	if x.TotalMovingTime == 0xFFFFFFFF {
		return math.NaN()
	}
	return float64(x.TotalMovingTime) / 1000
}

// GetAvgPosVerticalSpeedScaled returns AvgPosVerticalSpeed
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: m/s
func (x *SegmentLapMsg) GetAvgPosVerticalSpeedScaled() float64 {
	if x.AvgPosVerticalSpeed == 0x7FFF {
		return math.NaN()
	}
	return float64(x.AvgPosVerticalSpeed) / 1000
}

// GetAvgNegVerticalSpeedScaled returns AvgNegVerticalSpeed
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: m/s
func (x *SegmentLapMsg) GetAvgNegVerticalSpeedScaled() float64 {
	if x.AvgNegVerticalSpeed == 0x7FFF {
		return math.NaN()
	}
	return float64(x.AvgNegVerticalSpeed) / 1000
}

// GetMaxPosVerticalSpeedScaled returns MaxPosVerticalSpeed
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: m/s
func (x *SegmentLapMsg) GetMaxPosVerticalSpeedScaled() float64 {
	if x.MaxPosVerticalSpeed == 0x7FFF {
		return math.NaN()
	}
	return float64(x.MaxPosVerticalSpeed) / 1000
}

// GetMaxNegVerticalSpeedScaled returns MaxNegVerticalSpeed
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: m/s
func (x *SegmentLapMsg) GetMaxNegVerticalSpeedScaled() float64 {
	if x.MaxNegVerticalSpeed == 0x7FFF {
		return math.NaN()
	}
	return float64(x.MaxNegVerticalSpeed) / 1000
}

// GetTimeInHrZoneScaled returns TimeInHrZone
// as a slice with scale and any offset applied to every element.
// Units: s
func (x *SegmentLapMsg) GetTimeInHrZoneScaled() []float64 {
	if len(x.TimeInHrZone) == 0 {
		return nil
	}
	s := make([]float64, len(x.TimeInHrZone))
	for i, v := range x.TimeInHrZone {
		s[i] = float64(v) / 1000
	}
	return s
}

// GetTimeInSpeedZoneScaled returns TimeInSpeedZone
// as a slice with scale and any offset applied to every element.
// Units: s
func (x *SegmentLapMsg) GetTimeInSpeedZoneScaled() []float64 {
	if len(x.TimeInSpeedZone) == 0 {
		return nil
	}
	s := make([]float64, len(x.TimeInSpeedZone))
	for i, v := range x.TimeInSpeedZone {
		s[i] = float64(v) / 1000
	}
	return s
}

// GetTimeInCadenceZoneScaled returns TimeInCadenceZone
// as a slice with scale and any offset applied to every element.
// Units: s
func (x *SegmentLapMsg) GetTimeInCadenceZoneScaled() []float64 {
	if len(x.TimeInCadenceZone) == 0 {
		return nil
	}
	s := make([]float64, len(x.TimeInCadenceZone))
	for i, v := range x.TimeInCadenceZone {
		s[i] = float64(v) / 1000
	}
	return s
}

// GetTimeInPowerZoneScaled returns TimeInPowerZone
// as a slice with scale and any offset applied to every element.
// Units: s
func (x *SegmentLapMsg) GetTimeInPowerZoneScaled() []float64 {
	if len(x.TimeInPowerZone) == 0 {
		return nil
	}
	s := make([]float64, len(x.TimeInPowerZone))
	for i, v := range x.TimeInPowerZone {
		s[i] = float64(v) / 1000
	}
	return s
}

// GetMinAltitudeScaled returns MinAltitude
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: m
func (x *SegmentLapMsg) GetMinAltitudeScaled() float64 {
	if x.MinAltitude == 0xFFFF {
		return math.NaN()
	}
	return float64(x.MinAltitude)/5 - 500
}

// GetActiveTimeScaled returns ActiveTime
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: s
func (x *SegmentLapMsg) GetActiveTimeScaled() float64 {
	if x.ActiveTime == 0xFFFFFFFF {
		return math.NaN()
	}
	return float64(x.ActiveTime) / 1000
}

// GetAvgLeftTorqueEffectivenessScaled returns AvgLeftTorqueEffectiveness
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: percent
func (x *SegmentLapMsg) GetAvgLeftTorqueEffectivenessScaled() float64 {
	if x.AvgLeftTorqueEffectiveness == 0xFF {
		return math.NaN()
	}
	return float64(x.AvgLeftTorqueEffectiveness) / 2
}

// GetAvgRightTorqueEffectivenessScaled returns AvgRightTorqueEffectiveness
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: percent
func (x *SegmentLapMsg) GetAvgRightTorqueEffectivenessScaled() float64 {
	if x.AvgRightTorqueEffectiveness == 0xFF {
		return math.NaN()
	}
	return float64(x.AvgRightTorqueEffectiveness) / 2
}

// GetAvgLeftPedalSmoothnessScaled returns AvgLeftPedalSmoothness
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: percent
func (x *SegmentLapMsg) GetAvgLeftPedalSmoothnessScaled() float64 {
	if x.AvgLeftPedalSmoothness == 0xFF {
		return math.NaN()
	}
	return float64(x.AvgLeftPedalSmoothness) / 2
}

// GetAvgRightPedalSmoothnessScaled returns AvgRightPedalSmoothness
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: percent
func (x *SegmentLapMsg) GetAvgRightPedalSmoothnessScaled() float64 {
	if x.AvgRightPedalSmoothness == 0xFF {
		return math.NaN()
	}
	return float64(x.AvgRightPedalSmoothness) / 2
}

// GetAvgCombinedPedalSmoothnessScaled returns AvgCombinedPedalSmoothness
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: percent
func (x *SegmentLapMsg) GetAvgCombinedPedalSmoothnessScaled() float64 {
	if x.AvgCombinedPedalSmoothness == 0xFF {
		return math.NaN()
	}
	return float64(x.AvgCombinedPedalSmoothness) / 2
}

// GetAvgFractionalCadenceScaled returns AvgFractionalCadence
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: rpm
func (x *SegmentLapMsg) GetAvgFractionalCadenceScaled() float64 {
	if x.AvgFractionalCadence == 0xFF {
		return math.NaN()
	}
	return float64(x.AvgFractionalCadence) / 128
}

// GetMaxFractionalCadenceScaled returns MaxFractionalCadence
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: rpm
func (x *SegmentLapMsg) GetMaxFractionalCadenceScaled() float64 {
	if x.MaxFractionalCadence == 0xFF {
		return math.NaN()
	}
	return float64(x.MaxFractionalCadence) / 128
}

// GetTotalFractionalCyclesScaled returns TotalFractionalCycles
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: cycles
func (x *SegmentLapMsg) GetTotalFractionalCyclesScaled() float64 {
	if x.TotalFractionalCycles == 0xFF {
		return math.NaN()
	}
	return float64(x.TotalFractionalCycles) / 128
}

// GetTotalCycles returns the appropriate TotalCycles
// subfield if a matching reference field/value combination is found.
// If none of the reference field/value combinations are true
// then the main field is returned.
func (x *SegmentLapMsg) GetTotalCycles() interface{} {
	switch x.Sport {
	case SportCycling:
		return uint32(x.TotalCycles)
	default:
		return x.TotalCycles
	}
}

// SegmentFileMsg represents the segment_file FIT message type.
type SegmentFileMsg struct {
	MessageIndex          MessageIndex
	FileUuid              string                   // UUID of the segment file
	Enabled               Bool                     // Enabled state of the segment file
	UserProfilePrimaryKey uint32                   // Primary key of the user that created the segment file
	LeaderType            []SegmentLeaderboardType // Leader type of each leader in the segment file
	LeaderGroupPrimaryKey []uint32                 // Group primary key of each leader in the segment file
	LeaderActivityId      []uint32                 // Activity ID of each leader in the segment file
}

// WorkoutMsg represents the workout FIT message type.
type WorkoutMsg struct {
	Sport         Sport
	Capabilities  WorkoutCapabilities
	NumValidSteps uint16 // number of valid steps
	WktName       string
}

// WorkoutStepMsg represents the workout_step FIT message type.
type WorkoutStepMsg struct {
	MessageIndex          MessageIndex
	WktStepName           string
	DurationType          WktStepDuration
	DurationValue         uint32
	TargetType            WktStepTarget
	TargetValue           uint32
	CustomTargetValueLow  uint32
	CustomTargetValueHigh uint32
	Intensity             Intensity
}

// GetDurationValue returns the appropriate DurationValue
// subfield if a matching reference field/value combination is found.
// If none of the reference field/value combinations are true
// then the main field is returned.
func (x *WorkoutStepMsg) GetDurationValue() interface{} {
	switch x.DurationType {
	case WktStepDurationTime, WktStepDurationRepetitionTime:
		return float64(x.DurationValue) / 1000
	case WktStepDurationDistance:
		return float64(x.DurationValue) / 100
	case WktStepDurationHrLessThan, WktStepDurationHrGreaterThan:
		return WorkoutHr(x.DurationValue)
	case WktStepDurationCalories:
		return uint32(x.DurationValue)
	case WktStepDurationRepeatUntilStepsCmplt, WktStepDurationRepeatUntilTime, WktStepDurationRepeatUntilDistance, WktStepDurationRepeatUntilCalories, WktStepDurationRepeatUntilHrLessThan, WktStepDurationRepeatUntilHrGreaterThan, WktStepDurationRepeatUntilPowerLessThan, WktStepDurationRepeatUntilPowerGreaterThan:
		return uint32(x.DurationValue)
	case WktStepDurationPowerLessThan, WktStepDurationPowerGreaterThan:
		return WorkoutPower(x.DurationValue)
	default:
		return x.DurationValue
	}
}

// GetTargetValue returns the appropriate TargetValue
// subfield if a matching reference field/value combination is found.
// If none of the reference field/value combinations are true
// then the main field is returned.
func (x *WorkoutStepMsg) GetTargetValue() interface{} {
	switch {
	case x.TargetType == WktStepTargetHeartRate:
		return uint32(x.TargetValue)
	case x.TargetType == WktStepTargetPower:
		return uint32(x.TargetValue)
	case x.DurationType == WktStepDurationRepeatUntilStepsCmplt:
		return uint32(x.TargetValue)
	case x.DurationType == WktStepDurationRepeatUntilTime:
		return float64(x.TargetValue) / 1000
	case x.DurationType == WktStepDurationRepeatUntilDistance:
		return float64(x.TargetValue) / 100
	case x.DurationType == WktStepDurationRepeatUntilCalories:
		return uint32(x.TargetValue)
	case x.DurationType == WktStepDurationRepeatUntilHrLessThan:
		return WorkoutHr(x.TargetValue)
	case x.DurationType == WktStepDurationRepeatUntilHrGreaterThan:
		return WorkoutHr(x.TargetValue)
	case x.DurationType == WktStepDurationRepeatUntilPowerLessThan:
		return WorkoutPower(x.TargetValue)
	case x.DurationType == WktStepDurationRepeatUntilPowerGreaterThan:
		return WorkoutPower(x.TargetValue)
	default:
		return x.TargetValue
	}
}

// GetCustomTargetValueLow returns the appropriate CustomTargetValueLow
// subfield if a matching reference field/value combination is found.
// If none of the reference field/value combinations are true
// then the main field is returned.
func (x *WorkoutStepMsg) GetCustomTargetValueLow() interface{} {
	switch x.TargetType {
	case WktStepTargetSpeed:
		return float64(x.CustomTargetValueLow) / 1000
	case WktStepTargetHeartRate:
		return WorkoutHr(x.CustomTargetValueLow)
	case WktStepTargetCadence:
		return uint32(x.CustomTargetValueLow)
	case WktStepTargetPower:
		return WorkoutPower(x.CustomTargetValueLow)
	default:
		return x.CustomTargetValueLow
	}
}

// GetCustomTargetValueHigh returns the appropriate CustomTargetValueHigh
// subfield if a matching reference field/value combination is found.
// If none of the reference field/value combinations are true
// then the main field is returned.
func (x *WorkoutStepMsg) GetCustomTargetValueHigh() interface{} {
	switch x.TargetType {
	case WktStepTargetSpeed:
		return float64(x.CustomTargetValueHigh) / 1000
	case WktStepTargetHeartRate:
		return WorkoutHr(x.CustomTargetValueHigh)
	case WktStepTargetCadence:
		return uint32(x.CustomTargetValueHigh)
	case WktStepTargetPower:
		return WorkoutPower(x.CustomTargetValueHigh)
	default:
		return x.CustomTargetValueHigh
	}
}

// ScheduleMsg represents the schedule FIT message type.
type ScheduleMsg struct {
	Manufacturer  Manufacturer // Corresponds to file_id of scheduled workout / course.
	Product       uint16       // Corresponds to file_id of scheduled workout / course.
	SerialNumber  uint32       // Corresponds to file_id of scheduled workout / course.
	TimeCreated   time.Time    // Corresponds to file_id of scheduled workout / course.
	Completed     Bool         // TRUE if this activity has been started
	Type          Schedule
	ScheduledTime time.Time
}

// GetProduct returns the appropriate Product
// subfield if a matching reference field/value combination is found.
// If none of the reference field/value combinations are true
// then the main field is returned.
func (x *ScheduleMsg) GetProduct() interface{} {
	switch x.Manufacturer {
	case ManufacturerGarmin, ManufacturerDynastream, ManufacturerDynastreamOem:
		return GarminProduct(x.Product)
	default:
		return x.Product
	}
}

// TotalsMsg represents the totals FIT message type.
type TotalsMsg struct {
	MessageIndex MessageIndex
	Timestamp    time.Time
	TimerTime    uint32 // Excludes pauses
	Distance     uint32
	Calories     uint32
	Sport        Sport
	ElapsedTime  uint32 // Includes pauses
	Sessions     uint16
	ActiveTime   uint32
}

// WeightScaleMsg represents the weight_scale FIT message type.
type WeightScaleMsg struct {
	Timestamp         time.Time
	Weight            Weight
	PercentFat        uint16
	PercentHydration  uint16
	VisceralFatMass   uint16
	BoneMass          uint16
	MuscleMass        uint16
	BasalMet          uint16
	PhysiqueRating    uint8
	ActiveMet         uint16 // ~4kJ per kcal, 0.25 allows max 16384 kcal
	MetabolicAge      uint8
	VisceralFatRating uint8
	UserProfileIndex  MessageIndex // Associates this weight scale message to a user.  This corresponds to the index of the user profile message in the weight scale file.
}

// GetWeightScaled returns Weight
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: kg
func (x *WeightScaleMsg) GetWeightScaled() float64 {
	if x.Weight == 0xFFFF {
		return math.NaN()
	}
	return float64(x.Weight) / 100
}

// GetPercentFatScaled returns PercentFat
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: %
func (x *WeightScaleMsg) GetPercentFatScaled() float64 {
	if x.PercentFat == 0xFFFF {
		return math.NaN()
	}
	return float64(x.PercentFat) / 100
}

// GetPercentHydrationScaled returns PercentHydration
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: %
func (x *WeightScaleMsg) GetPercentHydrationScaled() float64 {
	if x.PercentHydration == 0xFFFF {
		return math.NaN()
	}
	return float64(x.PercentHydration) / 100
}

// GetVisceralFatMassScaled returns VisceralFatMass
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: kg
func (x *WeightScaleMsg) GetVisceralFatMassScaled() float64 {
	if x.VisceralFatMass == 0xFFFF {
		return math.NaN()
	}
	return float64(x.VisceralFatMass) / 100
}

// GetBoneMassScaled returns BoneMass
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: kg
func (x *WeightScaleMsg) GetBoneMassScaled() float64 {
	if x.BoneMass == 0xFFFF {
		return math.NaN()
	}
	return float64(x.BoneMass) / 100
}

// GetMuscleMassScaled returns MuscleMass
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: kg
func (x *WeightScaleMsg) GetMuscleMassScaled() float64 {
	if x.MuscleMass == 0xFFFF {
		return math.NaN()
	}
	return float64(x.MuscleMass) / 100
}

// GetBasalMetScaled returns BasalMet
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: kcal/day
func (x *WeightScaleMsg) GetBasalMetScaled() float64 {
	if x.BasalMet == 0xFFFF {
		return math.NaN()
	}
	return float64(x.BasalMet) / 4
}

// GetActiveMetScaled returns ActiveMet
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: kcal/day
func (x *WeightScaleMsg) GetActiveMetScaled() float64 {
	if x.ActiveMet == 0xFFFF {
		return math.NaN()
	}
	return float64(x.ActiveMet) / 4
}

// BloodPressureMsg represents the blood_pressure FIT message type.
type BloodPressureMsg struct {
	Timestamp            time.Time
	SystolicPressure     uint16
	DiastolicPressure    uint16
	MeanArterialPressure uint16
	Map3SampleMean       uint16
	MapMorningValues     uint16
	MapEveningValues     uint16
	HeartRate            uint8
	HeartRateType        HrType
	Status               BpStatus
	UserProfileIndex     MessageIndex // Associates this blood pressure message to a user.  This corresponds to the index of the user profile message in the blood pressure file.
}

// MonitoringInfoMsg represents the monitoring_info FIT message type.
type MonitoringInfoMsg struct {
	Timestamp      time.Time
	LocalTimestamp time.Time // Use to convert activity timestamps to local time if device does not support time zone and daylight savings time correction.
}

// MonitoringMsg represents the monitoring FIT message type.
type MonitoringMsg struct {
	Timestamp       time.Time   // Must align to logging interval, for example, time must be 00:00:00 for daily log.
	DeviceIndex     DeviceIndex // Associates this data to device_info message.  Not required for file with single device (sensor).
	Calories        uint16      // Accumulated total calories.  Maintained by MonitoringReader for each activity_type.  See SDK documentation
	Distance        uint32      // Accumulated distance.  Maintained by MonitoringReader for each activity_type.  See SDK documentation.
	Cycles          uint32      // Accumulated cycles.  Maintained by MonitoringReader for each activity_type.  See SDK documentation.
	ActiveTime      uint32
	ActivityType    ActivityType
	ActivitySubtype ActivitySubtype
	Distance16      uint16
	Cycles16        uint16
	ActiveTime16    uint16
	LocalTimestamp  time.Time // Must align to logging interval, for example, time must be 00:00:00 for daily log.
}

// GetDistanceScaled returns Distance
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: m
func (x *MonitoringMsg) GetDistanceScaled() float64 {
	if x.Distance == 0xFFFFFFFF {
		return math.NaN()
	}
	return float64(x.Distance) / 100
}

// GetCyclesScaled returns Cycles
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: cycles
func (x *MonitoringMsg) GetCyclesScaled() float64 {
	if x.Cycles == 0xFFFFFFFF {
		return math.NaN()
	}
	return float64(x.Cycles) / 2
}

// GetActiveTimeScaled returns ActiveTime
// with scale and any offset applied. NaN is returned if the
// field has an invalid value (i.e. has not been set).
// Units: s
func (x *MonitoringMsg) GetActiveTimeScaled() float64 {
	if x.ActiveTime == 0xFFFFFFFF {
		return math.NaN()
	}
	return float64(x.ActiveTime) / 1000
}

// GetCycles returns the appropriate Cycles
// subfield if a matching reference field/value combination is found.
// If none of the reference field/value combinations are true
// then the main field is returned.
func (x *MonitoringMsg) GetCycles() interface{} {
	switch x.ActivityType {
	case ActivityTypeCycling, ActivityTypeSwimming:
		return float64(x.Cycles) / 2
	default:
		return x.Cycles
	}
}

// MemoGlobMsg represents the memo_glob FIT message type.
type MemoGlobMsg struct {
}
// PROFILE
// This file is auto-generated using the
// program found in 'cmd/fitgen/main.go'
// DO NOT EDIT.
// SDK Version: Unknown

package fit

import (
	"fmt"
	"reflect"

	"github.com/tormoder/fit/internal/base"
)

// field represents a fit message field in the profile field lookup table.
type field struct {
	sindex int
	array  uint8
	t      gotype
	num    byte
	btype  base.Type
}

func (f field) String() string {
	return fmt.Sprintf(
		"num: %d | btype: %v | sindex: %d | array: %d",
		f.num, f.btype, f.sindex, f.array,
	)
}

// gotype is used in the profile field lookup table to represent the data type
// (or type category) for a field when decoded into a Go message struct.
type gotype uint8

const (
	fit gotype = iota // Standard -> Fit base type/alias

	// Special (non-profile types)
	timeutc   // Time UTC 	-> time.Time
	timelocal // Time Local -> time.Time with Location
	lat       // Latitude 	-> fit.Latitude
	lng       // Longitude 	-> fit.Longitude
)

func (g gotype) String() string {
	if int(g) > len(gotypeString) {
		return fmt.Sprintf("gotype(%d)", g)
	}
	return gotypeString[g]
}

var gotypeString = [...]string{
	"fit",
	"timeutc",
	"timelocal",
	"lat",
	"lng",
}

var knownMsgNums = map[MesgNum]bool{
	MesgNumFileId:                  true,
	MesgNumCapabilities:            true,
	MesgNumDeviceSettings:          true,
	MesgNumUserProfile:             true,
	MesgNumHrmProfile:              true,
	MesgNumSdmProfile:              true,
	MesgNumBikeProfile:             true,
	MesgNumZonesTarget:             true,
	MesgNumHrZone:                  true,
	MesgNumPowerZone:               true,
	MesgNumMetZone:                 true,
	MesgNumSport:                   true,
	MesgNumGoal:                    true,
	MesgNumSession:                 true,
	MesgNumLap:                     true,
	MesgNumRecord:                  true,
	MesgNumEvent:                   true,
	MesgNumDeviceInfo:              true,
	MesgNumWorkout:                 true,
	MesgNumWorkoutStep:             true,
	MesgNumSchedule:                true,
	MesgNumWeightScale:             true,
	MesgNumCourse:                  true,
	MesgNumCoursePoint:             true,
	MesgNumTotals:                  true,
	MesgNumActivity:                true,
	MesgNumSoftware:                true,
	MesgNumFileCapabilities:        true,
	MesgNumMesgCapabilities:        true,
	MesgNumFieldCapabilities:       true,
	MesgNumFileCreator:             true,
	MesgNumBloodPressure:           true,
	MesgNumSpeedZone:               true,
	MesgNumMonitoring:              true,
	MesgNumTrainingFile:            true,
	MesgNumHrv:                     true,
	MesgNumLength:                  true,
	MesgNumMonitoringInfo:          true,
	MesgNumSlaveDevice:             true,
	MesgNumCadenceZone:             true,
	MesgNumSegmentLap:              true,
	MesgNumMemoGlob:                true,
	MesgNumSegmentId:               true,
	MesgNumSegmentLeaderboardEntry: true,
	MesgNumSegmentPoint:            true,
	MesgNumSegmentFile:             true,
	MesgNumCameraEvent:             true,
	MesgNumTimestampCorrelation:    true,
	MesgNumGyroscopeData:           true,
	MesgNumAccelerometerData:       true,
	MesgNumThreeDSensorCalibration: true,
	MesgNumVideoFrame:              true,
	MesgNumObdiiData:               true,
	MesgNumNmeaSentence:            true,
	MesgNumAviationAttitude:        true,
	MesgNumVideo:                   true,
	MesgNumVideoTitle:              true,
	MesgNumVideoDescription:        true,
	MesgNumVideoClip:               true,
}

var (
	accumuDistance         *uint32Accumulator
	accumuTotalCycles      *uint32Accumulator
	accumuAccumulatedPower *uint32Accumulator
)

// Set length to 256, so that lookup for any
// field 255 (localMesgNumInvalid) will return nil.
var _fields = [...][256]*field{
	MesgNumFileId: {
		0: {0, 0, fit, 0, base.Enum},
		1: {1, 0, fit, 1, base.Uint16},
		2: {2, 0, fit, 2, base.Uint16},
		3: {3, 0, fit, 3, base.Uint32z},
		4: {4, 0, timeutc, 4, base.Uint32},
		5: {5, 0, fit, 5, base.Uint16},
		8: {6, 0, fit, 8, base.String},
	},

	MesgNumFileCreator: {
		0: {0, 0, fit, 0, base.Uint16},
		1: {1, 0, fit, 1, base.Uint8},
	},

	MesgNumTimestampCorrelation: {},

	MesgNumSoftware: {
		254: {0, 0, fit, 254, base.Uint16},
		3:   {1, 0, fit, 3, base.Uint16},
		5:   {2, 0, fit, 5, base.String},
	},

	MesgNumSlaveDevice: {
		0: {0, 0, fit, 0, base.Uint16},
		1: {1, 0, fit, 1, base.Uint16},
	},

	MesgNumCapabilities: {
		0:  {0, 255, fit, 0, base.Uint8z},
		1:  {1, 255, fit, 1, base.Uint8z},
		21: {2, 0, fit, 21, base.Uint32z},
		23: {3, 0, fit, 23, base.Uint32z},
	},

	MesgNumFileCapabilities: {
		254: {0, 0, fit, 254, base.Uint16},
		0:   {1, 0, fit, 0, base.Enum},
		1:   {2, 0, fit, 1, base.Uint8z},
		2:   {3, 0, fit, 2, base.String},
		3:   {4, 0, fit, 3, base.Uint16},
		4:   {5, 0, fit, 4, base.Uint32},
	},

	MesgNumMesgCapabilities: {
		254: {0, 0, fit, 254, base.Uint16},
		0:   {1, 0, fit, 0, base.Enum},
		1:   {2, 0, fit, 1, base.Uint16},
		2:   {3, 0, fit, 2, base.Enum},
		3:   {4, 0, fit, 3, base.Uint16},
	},

	MesgNumFieldCapabilities: {
		254: {0, 0, fit, 254, base.Uint16},
		0:   {1, 0, fit, 0, base.Enum},
		1:   {2, 0, fit, 1, base.Uint16},
		2:   {3, 0, fit, 2, base.Uint8},
		3:   {4, 0, fit, 3, base.Uint16},
	},

	MesgNumDeviceSettings: {
		0: {0, 0, fit, 0, base.Uint8},
		1: {1, 0, fit, 1, base.Uint32},
		5: {2, 255, fit, 5, base.Sint8},
	},

	MesgNumUserProfile: {
		254: {0, 0, fit, 254, base.Uint16},
		0:   {1, 0, fit, 0, base.String},
		1:   {2, 0, fit, 1, base.Enum},
		2:   {3, 0, fit, 2, base.Uint8},
		3:   {4, 0, fit, 3, base.Uint8},
		4:   {5, 0, fit, 4, base.Uint16},
		5:   {6, 0, fit, 5, base.Enum},
		6:   {7, 0, fit, 6, base.Enum},
		7:   {8, 0, fit, 7, base.Enum},
		8:   {9, 0, fit, 8, base.Uint8},
		9:   {10, 0, fit, 9, base.Uint8},
		10:  {11, 0, fit, 10, base.Uint8},
		11:  {12, 0, fit, 11, base.Uint8},
		12:  {13, 0, fit, 12, base.Enum},
		13:  {14, 0, fit, 13, base.Enum},
		14:  {15, 0, fit, 14, base.Enum},
		16:  {16, 0, fit, 16, base.Enum},
		17:  {17, 0, fit, 17, base.Enum},
		18:  {18, 0, fit, 18, base.Enum},
		21:  {19, 0, fit, 21, base.Enum},
		22:  {20, 0, fit, 22, base.Uint16},
		23:  {21, 6, fit, 23, base.Byte},
		30:  {22, 0, fit, 30, base.Enum},
	},

	MesgNumHrmProfile: {
		254: {0, 0, fit, 254, base.Uint16},
		0:   {1, 0, fit, 0, base.Enum},
		1:   {2, 0, fit, 1, base.Uint16z},
		2:   {3, 0, fit, 2, base.Enum},
		3:   {4, 0, fit, 3, base.Uint8z},
	},

	MesgNumSdmProfile: {
		254: {0, 0, fit, 254, base.Uint16},
		0:   {1, 0, fit, 0, base.Enum},
		1:   {2, 0, fit, 1, base.Uint16z},
		2:   {3, 0, fit, 2, base.Uint16},
		3:   {4, 0, fit, 3, base.Uint32},
		4:   {5, 0, fit, 4, base.Enum},
		5:   {6, 0, fit, 5, base.Uint8z},
		7:   {7, 0, fit, 7, base.Uint8},
	},

	MesgNumBikeProfile: {
		254: {0, 0, fit, 254, base.Uint16},
		0:   {1, 0, fit, 0, base.String},
		1:   {2, 0, fit, 1, base.Enum},
		2:   {3, 0, fit, 2, base.Enum},
		3:   {4, 0, fit, 3, base.Uint32},
		4:   {5, 0, fit, 4, base.Uint16z},
		5:   {6, 0, fit, 5, base.Uint16z},
		6:   {7, 0, fit, 6, base.Uint16z},
		7:   {8, 0, fit, 7, base.Uint16z},
		8:   {9, 0, fit, 8, base.Uint16},
		9:   {10, 0, fit, 9, base.Uint16},
		10:  {11, 0, fit, 10, base.Uint16},
		11:  {12, 0, fit, 11, base.Uint16},
		12:  {13, 0, fit, 12, base.Enum},
		13:  {14, 0, fit, 13, base.Enum},
		14:  {15, 0, fit, 14, base.Uint8},
		15:  {16, 0, fit, 15, base.Enum},
		16:  {17, 0, fit, 16, base.Enum},
		17:  {18, 0, fit, 17, base.Enum},
		18:  {19, 0, fit, 18, base.Enum},
		19:  {20, 0, fit, 19, base.Uint8},
		20:  {21, 0, fit, 20, base.Enum},
		21:  {22, 0, fit, 21, base.Uint8z},
		22:  {23, 0, fit, 22, base.Uint8z},
		23:  {24, 0, fit, 23, base.Uint8z},
		24:  {25, 0, fit, 24, base.Uint8z},
		37:  {26, 0, fit, 37, base.Uint8},
		38:  {27, 0, fit, 38, base.Uint8z},
		39:  {28, 255, fit, 39, base.Uint8z},
		40:  {29, 0, fit, 40, base.Uint8z},
		41:  {30, 255, fit, 41, base.Uint8z},
		44:  {31, 0, fit, 44, base.Enum},
	},

	MesgNumZonesTarget: {
		1: {0, 0, fit, 1, base.Uint8},
		2: {1, 0, fit, 2, base.Uint8},
		3: {2, 0, fit, 3, base.Uint16},
		5: {3, 0, fit, 5, base.Enum},
		7: {4, 0, fit, 7, base.Enum},
	},

	MesgNumSport: {
		0: {0, 0, fit, 0, base.Enum},
		1: {1, 0, fit, 1, base.Enum},
		3: {2, 0, fit, 3, base.String},
	},

	MesgNumHrZone: {
		254: {0, 0, fit, 254, base.Uint16},
		1:   {1, 0, fit, 1, base.Uint8},
		2:   {2, 0, fit, 2, base.String},
	},

	MesgNumSpeedZone: {
		254: {0, 0, fit, 254, base.Uint16},
		0:   {1, 0, fit, 0, base.Uint16},
		1:   {2, 0, fit, 1, base.String},
	},

	MesgNumCadenceZone: {
		254: {0, 0, fit, 254, base.Uint16},
		0:   {1, 0, fit, 0, base.Uint8},
		1:   {2, 0, fit, 1, base.String},
	},

	MesgNumPowerZone: {
		254: {0, 0, fit, 254, base.Uint16},
		1:   {1, 0, fit, 1, base.Uint16},
		2:   {2, 0, fit, 2, base.String},
	},

	MesgNumMetZone: {
		254: {0, 0, fit, 254, base.Uint16},
		1:   {1, 0, fit, 1, base.Uint8},
		2:   {2, 0, fit, 2, base.Uint16},
		3:   {3, 0, fit, 3, base.Uint8},
	},

	MesgNumGoal: {
		254: {0, 0, fit, 254, base.Uint16},
		0:   {1, 0, fit, 0, base.Enum},
		1:   {2, 0, fit, 1, base.Enum},
		2:   {3, 0, timeutc, 2, base.Uint32},
		3:   {4, 0, timeutc, 3, base.Uint32},
		4:   {5, 0, fit, 4, base.Enum},
		5:   {6, 0, fit, 5, base.Uint32},
		6:   {7, 0, fit, 6, base.Enum},
		7:   {8, 0, fit, 7, base.Uint32},
		8:   {9, 0, fit, 8, base.Enum},
		9:   {10, 0, fit, 9, base.Uint16},
		10:  {11, 0, fit, 10, base.Enum},
	},

	MesgNumActivity: {
		253: {0, 0, timeutc, 253, base.Uint32},
		0:   {1, 0, fit, 0, base.Uint32},
		1:   {2, 0, fit, 1, base.Uint16},
		2:   {3, 0, fit, 2, base.Enum},
		3:   {4, 0, fit, 3, base.Enum},
		4:   {5, 0, fit, 4, base.Enum},
		5:   {6, 0, timelocal, 5, base.Uint32},
		6:   {7, 0, fit, 6, base.Uint8},
	},

	MesgNumSession: {
		254: {0, 0, fit, 254, base.Uint16},
		253: {1, 0, timeutc, 253, base.Uint32},
		0:   {2, 0, fit, 0, base.Enum},
		1:   {3, 0, fit, 1, base.Enum},
		2:   {4, 0, timeutc, 2, base.Uint32},
		3:   {5, 0, lat, 3, base.Sint32},
		4:   {6, 0, lng, 4, base.Sint32},
		5:   {7, 0, fit, 5, base.Enum},
		6:   {8, 0, fit, 6, base.Enum},
		7:   {9, 0, fit, 7, base.Uint32},
		8:   {10, 0, fit, 8, base.Uint32},
		9:   {11, 0, fit, 9, base.Uint32},
		10:  {12, 0, fit, 10, base.Uint32},
		11:  {13, 0, fit, 11, base.Uint16},
		13:  {14, 0, fit, 13, base.Uint16},
		14:  {15, 0, fit, 14, base.Uint16},
		15:  {16, 0, fit, 15, base.Uint16},
		16:  {17, 0, fit, 16, base.Uint8},
		17:  {18, 0, fit, 17, base.Uint8},
		18:  {19, 0, fit, 18, base.Uint8},
		19:  {20, 0, fit, 19, base.Uint8},
		20:  {21, 0, fit, 20, base.Uint16},
		21:  {22, 0, fit, 21, base.Uint16},
		22:  {23, 0, fit, 22, base.Uint16},
		23:  {24, 0, fit, 23, base.Uint16},
		24:  {25, 0, fit, 24, base.Uint8},
		25:  {26, 0, fit, 25, base.Uint16},
		26:  {27, 0, fit, 26, base.Uint16},
		27:  {28, 0, fit, 27, base.Uint8},
		28:  {29, 0, fit, 28, base.Enum},
		29:  {30, 0, lat, 29, base.Sint32},
		30:  {31, 0, lng, 30, base.Sint32},
		31:  {32, 0, lat, 31, base.Sint32},
		32:  {33, 0, lng, 32, base.Sint32},
		34:  {34, 0, fit, 34, base.Uint16},
		35:  {35, 0, fit, 35, base.Uint16},
		36:  {36, 0, fit, 36, base.Uint16},
		37:  {37, 0, fit, 37, base.Uint16},
		41:  {38, 0, fit, 41, base.Uint32},
		42:  {39, 0, fit, 42, base.Uint16},
		43:  {40, 0, fit, 43, base.Enum},
		44:  {41, 0, fit, 44, base.Uint16},
		45:  {42, 0, fit, 45, base.Uint16},
		46:  {43, 0, fit, 46, base.Enum},
		47:  {44, 0, fit, 47, base.Uint16},
		48:  {45, 0, fit, 48, base.Uint32},
		49:  {46, 0, fit, 49, base.Uint16},
		50:  {47, 0, fit, 50, base.Uint16},
		51:  {48, 0, fit, 51, base.Uint8},
		52:  {49, 0, fit, 52, base.Sint16},
		53:  {50, 0, fit, 53, base.Sint16},
		54:  {51, 0, fit, 54, base.Sint16},
		55:  {52, 0, fit, 55, base.Sint16},
		56:  {53, 0, fit, 56, base.Sint16},
		57:  {54, 0, fit, 57, base.Sint8},
		58:  {55, 0, fit, 58, base.Sint8},
		59:  {56, 0, fit, 59, base.Uint32},
		60:  {57, 0, fit, 60, base.Sint16},
		61:  {58, 0, fit, 61, base.Sint16},
		62:  {59, 0, fit, 62, base.Sint16},
		63:  {60, 0, fit, 63, base.Sint16},
		64:  {61, 0, fit, 64, base.Uint8},
		65:  {62, 255, fit, 65, base.Uint32},
		66:  {63, 255, fit, 66, base.Uint32},
		67:  {64, 255, fit, 67, base.Uint32},
		68:  {65, 255, fit, 68, base.Uint32},
		69:  {66, 0, fit, 69, base.Uint32},
		70:  {67, 0, fit, 70, base.Uint16},
		71:  {68, 0, fit, 71, base.Uint16},
		82:  {69, 0, fit, 82, base.Uint16},
		83:  {70, 0, fit, 83, base.Uint16},
		84:  {71, 0, fit, 84, base.String},
		85:  {72, 255, fit, 85, base.Uint16},
		86:  {73, 255, fit, 86, base.Uint16},
		87:  {74, 0, fit, 87, base.Uint16},
		88:  {75, 0, fit, 88, base.Uint16},
		89:  {76, 0, fit, 89, base.Uint16},
		90:  {77, 0, fit, 90, base.Uint16},
		91:  {78, 0, fit, 91, base.Uint16},
		92:  {79, 0, fit, 92, base.Uint8},
		93:  {80, 0, fit, 93, base.Uint8},
		94:  {81, 0, fit, 94, base.Uint8},
		111: {82, 0, fit, 111, base.Uint8},
		124: {83, 0, fit, 124, base.Uint32},
		125: {84, 0, fit, 125, base.Uint32},
		126: {85, 0, fit, 126, base.Uint32},
		127: {86, 0, fit, 127, base.Uint32},
		128: {87, 0, fit, 128, base.Uint32},
	},

	MesgNumLap: {
		254: {0, 0, fit, 254, base.Uint16},
		253: {1, 0, timeutc, 253, base.Uint32},
		0:   {2, 0, fit, 0, base.Enum},
		1:   {3, 0, fit, 1, base.Enum},
		2:   {4, 0, timeutc, 2, base.Uint32},
		3:   {5, 0, lat, 3, base.Sint32},
		4:   {6, 0, lng, 4, base.Sint32},
		5:   {7, 0, lat, 5, base.Sint32},
		6:   {8, 0, lng, 6, base.Sint32},
		7:   {9, 0, fit, 7, base.Uint32},
		8:   {10, 0, fit, 8, base.Uint32},
		9:   {11, 0, fit, 9, base.Uint32},
		10:  {12, 0, fit, 10, base.Uint32},
		11:  {13, 0, fit, 11, base.Uint16},
		12:  {14, 0, fit, 12, base.Uint16},
		13:  {15, 0, fit, 13, base.Uint16},
		14:  {16, 0, fit, 14, base.Uint16},
		15:  {17, 0, fit, 15, base.Uint8},
		16:  {18, 0, fit, 16, base.Uint8},
		17:  {19, 0, fit, 17, base.Uint8},
		18:  {20, 0, fit, 18, base.Uint8},
		19:  {21, 0, fit, 19, base.Uint16},
		20:  {22, 0, fit, 20, base.Uint16},
		21:  {23, 0, fit, 21, base.Uint16},
		22:  {24, 0, fit, 22, base.Uint16},
		23:  {25, 0, fit, 23, base.Enum},
		24:  {26, 0, fit, 24, base.Enum},
		25:  {27, 0, fit, 25, base.Enum},
		26:  {28, 0, fit, 26, base.Uint8},
		32:  {29, 0, fit, 32, base.Uint16},
		33:  {30, 0, fit, 33, base.Uint16},
		34:  {31, 0, fit, 34, base.Uint16},
		35:  {32, 0, fit, 35, base.Uint16},
		37:  {33, 0, fit, 37, base.Uint16},
		38:  {34, 0, fit, 38, base.Enum},
		39:  {35, 0, fit, 39, base.Enum},
		40:  {36, 0, fit, 40, base.Uint16},
		41:  {37, 0, fit, 41, base.Uint32},
		42:  {38, 0, fit, 42, base.Uint16},
		43:  {39, 0, fit, 43, base.Uint16},
		44:  {40, 0, fit, 44, base.Uint8},
		45:  {41, 0, fit, 45, base.Sint16},
		46:  {42, 0, fit, 46, base.Sint16},
		47:  {43, 0, fit, 47, base.Sint16},
		48:  {44, 0, fit, 48, base.Sint16},
		49:  {45, 0, fit, 49, base.Sint16},
		50:  {46, 0, fit, 50, base.Sint8},
		51:  {47, 0, fit, 51, base.Sint8},
		52:  {48, 0, fit, 52, base.Uint32},
		53:  {49, 0, fit, 53, base.Sint16},
		54:  {50, 0, fit, 54, base.Sint16},
		55:  {51, 0, fit, 55, base.Sint16},
		56:  {52, 0, fit, 56, base.Sint16},
		57:  {53, 255, fit, 57, base.Uint32},
		58:  {54, 255, fit, 58, base.Uint32},
		59:  {55, 255, fit, 59, base.Uint32},
		60:  {56, 255, fit, 60, base.Uint32},
		61:  {57, 0, fit, 61, base.Uint16},
		62:  {58, 0, fit, 62, base.Uint16},
		63:  {59, 0, fit, 63, base.Uint8},
		71:  {60, 0, fit, 71, base.Uint16},
		74:  {61, 0, fit, 74, base.Uint16},
		75:  {62, 255, fit, 75, base.Uint16},
		76:  {63, 255, fit, 76, base.Uint16},
		77:  {64, 0, fit, 77, base.Uint16},
		78:  {65, 0, fit, 78, base.Uint16},
		79:  {66, 0, fit, 79, base.Uint16},
		80:  {67, 0, fit, 80, base.Uint8},
		81:  {68, 0, fit, 81, base.Uint8},
		82:  {69, 0, fit, 82, base.Uint8},
		83:  {70, 0, fit, 83, base.Uint16},
		84:  {71, 255, fit, 84, base.Uint16},
		85:  {72, 255, fit, 85, base.Uint16},
		86:  {73, 255, fit, 86, base.Uint16},
		87:  {74, 255, fit, 87, base.Uint16},
		88:  {75, 255, fit, 88, base.Uint16},
		89:  {76, 255, fit, 89, base.Uint16},
		110: {77, 0, fit, 110, base.Uint32},
		111: {78, 0, fit, 111, base.Uint32},
		112: {79, 0, fit, 112, base.Uint32},
		113: {80, 0, fit, 113, base.Uint32},
		114: {81, 0, fit, 114, base.Uint32},
	},

	MesgNumLength: {
		254: {0, 0, fit, 254, base.Uint16},
		253: {1, 0, timeutc, 253, base.Uint32},
		0:   {2, 0, fit, 0, base.Enum},
		1:   {3, 0, fit, 1, base.Enum},
		2:   {4, 0, timeutc, 2, base.Uint32},
		3:   {5, 0, fit, 3, base.Uint32},
		4:   {6, 0, fit, 4, base.Uint32},
		5:   {7, 0, fit, 5, base.Uint16},
		6:   {8, 0, fit, 6, base.Uint16},
		7:   {9, 0, fit, 7, base.Enum},
		9:   {10, 0, fit, 9, base.Uint8},
		10:  {11, 0, fit, 10, base.Uint8},
		11:  {12, 0, fit, 11, base.Uint16},
		12:  {13, 0, fit, 12, base.Enum},
		18:  {14, 0, fit, 18, base.Uint16},
		19:  {15, 0, fit, 19, base.Uint16},
		20:  {16, 255, fit, 20, base.Uint16},
		21:  {17, 255, fit, 21, base.Uint16},
	},

	MesgNumRecord: {
		253: {0, 0, timeutc, 253, base.Uint32},
		0:   {1, 0, lat, 0, base.Sint32},
		1:   {2, 0, lng, 1, base.Sint32},
		2:   {3, 0, fit, 2, base.Uint16},
		3:   {4, 0, fit, 3, base.Uint8},
		4:   {5, 0, fit, 4, base.Uint8},
		5:   {6, 0, fit, 5, base.Uint32},
		6:   {7, 0, fit, 6, base.Uint16},
		7:   {8, 0, fit, 7, base.Uint16},
		8:   {9, 3, fit, 8, base.Byte},
		9:   {10, 0, fit, 9, base.Sint16},
		10:  {11, 0, fit, 10, base.Uint8},
		11:  {12, 0, fit, 11, base.Sint32},
		12:  {13, 0, fit, 12, base.Uint8},
		13:  {14, 0, fit, 13, base.Sint8},
		17:  {15, 255, fit, 17, base.Uint8},
		18:  {16, 0, fit, 18, base.Uint8},
		19:  {17, 0, fit, 19, base.Uint32},
		28:  {18, 0, fit, 28, base.Uint16},
		29:  {19, 0, fit, 29, base.Uint32},
		30:  {20, 0, fit, 30, base.Uint8},
		31:  {21, 0, fit, 31, base.Uint8},
		32:  {22, 0, fit, 32, base.Sint16},
		33:  {23, 0, fit, 33, base.Uint16},
		39:  {24, 0, fit, 39, base.Uint16},
		40:  {25, 0, fit, 40, base.Uint16},
		41:  {26, 0, fit, 41, base.Uint16},
		42:  {27, 0, fit, 42, base.Enum},
		43:  {28, 0, fit, 43, base.Uint8},
		44:  {29, 0, fit, 44, base.Uint8},
		45:  {30, 0, fit, 45, base.Uint8},
		46:  {31, 0, fit, 46, base.Uint8},
		47:  {32, 0, fit, 47, base.Uint8},
		48:  {33, 0, fit, 48, base.Uint8},
		49:  {34, 0, fit, 49, base.Enum},
		50:  {35, 0, fit, 50, base.Uint8},
		51:  {36, 0, fit, 51, base.Uint16},
		52:  {37, 0, fit, 52, base.Uint16},
		53:  {38, 0, fit, 53, base.Uint8},
		54:  {39, 0, fit, 54, base.Uint16},
		55:  {40, 0, fit, 55, base.Uint16},
		56:  {41, 0, fit, 56, base.Uint16},
		57:  {42, 0, fit, 57, base.Uint16},
		58:  {43, 0, fit, 58, base.Uint16},
		59:  {44, 0, fit, 59, base.Uint16},
		62:  {45, 0, fit, 62, base.Uint8},
		73:  {46, 0, fit, 73, base.Uint32},
		78:  {47, 0, fit, 78, base.Uint32},
	},

	MesgNumEvent: {
		253: {0, 0, timeutc, 253, base.Uint32},
		0:   {1, 0, fit, 0, base.Enum},
		1:   {2, 0, fit, 1, base.Enum},
		2:   {3, 0, fit, 2, base.Uint16},
		3:   {4, 0, fit, 3, base.Uint32},
		4:   {5, 0, fit, 4, base.Uint8},
		7:   {6, 0, fit, 7, base.Uint16},
		8:   {7, 0, fit, 8, base.Uint16},
		9:   {8, 0, fit, 9, base.Uint8z},
		10:  {9, 0, fit, 10, base.Uint8z},
		11:  {10, 0, fit, 11, base.Uint8z},
		12:  {11, 0, fit, 12, base.Uint8z},
	},

	MesgNumDeviceInfo: {
		253: {0, 0, timeutc, 253, base.Uint32},
		0:   {1, 0, fit, 0, base.Uint8},
		1:   {2, 0, fit, 1, base.Uint8},
		2:   {3, 0, fit, 2, base.Uint16},
		3:   {4, 0, fit, 3, base.Uint32z},
		4:   {5, 0, fit, 4, base.Uint16},
		5:   {6, 0, fit, 5, base.Uint16},
		6:   {7, 0, fit, 6, base.Uint8},
		7:   {8, 0, fit, 7, base.Uint32},
		10:  {9, 0, fit, 10, base.Uint16},
		11:  {10, 0, fit, 11, base.Uint8},
		18:  {11, 0, fit, 18, base.Enum},
		19:  {12, 0, fit, 19, base.String},
		20:  {13, 0, fit, 20, base.Uint8z},
		21:  {14, 0, fit, 21, base.Uint16z},
		22:  {15, 0, fit, 22, base.Enum},
		25:  {16, 0, fit, 25, base.Enum},
		27:  {17, 0, fit, 27, base.String},
	},

	MesgNumTrainingFile: {
		253: {0, 0, timeutc, 253, base.Uint32},
		0:   {1, 0, fit, 0, base.Enum},
		1:   {2, 0, fit, 1, base.Uint16},
		2:   {3, 0, fit, 2, base.Uint16},
		3:   {4, 0, fit, 3, base.Uint32z},
		4:   {5, 0, timeutc, 4, base.Uint32},
	},

	MesgNumHrv: {
		0: {0, 255, fit, 0, base.Uint16},
	},

	MesgNumCameraEvent: {},

	MesgNumGyroscopeData: {},

	MesgNumAccelerometerData: {},

	MesgNumThreeDSensorCalibration: {},

	MesgNumVideoFrame: {},

	MesgNumObdiiData: {},

	MesgNumNmeaSentence: {
		253: {0, 0, timeutc, 253, base.Uint32},
		0:   {1, 0, fit, 0, base.Uint16},
		1:   {2, 0, fit, 1, base.String},
	},

	MesgNumAviationAttitude: {
		253: {0, 0, timeutc, 253, base.Uint32},
		0:   {1, 0, fit, 0, base.Uint16},
		1:   {2, 255, fit, 1, base.Uint32},
		2:   {3, 255, fit, 2, base.Sint16},
		3:   {4, 255, fit, 3, base.Sint16},
		4:   {5, 255, fit, 4, base.Sint16},
		5:   {6, 255, fit, 5, base.Sint16},
		6:   {7, 255, fit, 6, base.Sint16},
		7:   {8, 255, fit, 7, base.Enum},
		8:   {9, 255, fit, 8, base.Uint8},
		9:   {10, 255, fit, 9, base.Uint16},
		10:  {11, 255, fit, 10, base.Uint16},
	},

	MesgNumVideo: {},

	MesgNumVideoTitle: {
		254: {0, 0, fit, 254, base.Uint16},
		0:   {1, 0, fit, 0, base.Uint16},
		1:   {2, 0, fit, 1, base.String},
	},

	MesgNumVideoDescription: {
		254: {0, 0, fit, 254, base.Uint16},
		0:   {1, 0, fit, 0, base.Uint16},
		1:   {2, 0, fit, 1, base.String},
	},

	MesgNumVideoClip: {},

	MesgNumCourse: {
		4: {0, 0, fit, 4, base.Enum},
		5: {1, 0, fit, 5, base.String},
		6: {2, 0, fit, 6, base.Uint32z},
	},

	MesgNumCoursePoint: {
		254: {0, 0, fit, 254, base.Uint16},
		1:   {1, 0, timeutc, 1, base.Uint32},
		2:   {2, 0, lat, 2, base.Sint32},
		3:   {3, 0, lng, 3, base.Sint32},
		4:   {4, 0, fit, 4, base.Uint32},
		5:   {5, 0, fit, 5, base.Enum},
		6:   {6, 0, fit, 6, base.String},
		8:   {7, 0, fit, 8, base.Enum},
	},

	MesgNumSegmentId: {
		0: {0, 0, fit, 0, base.String},
		1: {1, 0, fit, 1, base.String},
		2: {2, 0, fit, 2, base.Enum},
		3: {3, 0, fit, 3, base.Enum},
		4: {4, 0, fit, 4, base.Uint32},
		5: {5, 0, fit, 5, base.Uint32},
		6: {6, 0, fit, 6, base.Uint8},
		7: {7, 0, fit, 7, base.Enum},
		8: {8, 0, fit, 8, base.Enum},
	},

	MesgNumSegmentLeaderboardEntry: {
		254: {0, 0, fit, 254, base.Uint16},
		0:   {1, 0, fit, 0, base.String},
		1:   {2, 0, fit, 1, base.Enum},
		2:   {3, 0, fit, 2, base.Uint32},
		3:   {4, 0, fit, 3, base.Uint32},
		4:   {5, 0, fit, 4, base.Uint32},
	},

	MesgNumSegmentPoint: {
		254: {0, 0, fit, 254, base.Uint16},
		1:   {1, 0, lat, 1, base.Sint32},
		2:   {2, 0, lng, 2, base.Sint32},
		3:   {3, 0, fit, 3, base.Uint32},
		4:   {4, 0, fit, 4, base.Uint16},
		5:   {5, 255, fit, 5, base.Uint32},
	},

	MesgNumSegmentLap: {
		254: {0, 0, fit, 254, base.Uint16},
		253: {1, 0, timeutc, 253, base.Uint32},
		0:   {2, 0, fit, 0, base.Enum},
		1:   {3, 0, fit, 1, base.Enum},
		2:   {4, 0, timeutc, 2, base.Uint32},
		3:   {5, 0, lat, 3, base.Sint32},
		4:   {6, 0, lng, 4, base.Sint32},
		5:   {7, 0, lat, 5, base.Sint32},
		6:   {8, 0, lng, 6, base.Sint32},
		7:   {9, 0, fit, 7, base.Uint32},
		8:   {10, 0, fit, 8, base.Uint32},
		9:   {11, 0, fit, 9, base.Uint32},
		10:  {12, 0, fit, 10, base.Uint32},
		11:  {13, 0, fit, 11, base.Uint16},
		12:  {14, 0, fit, 12, base.Uint16},
		13:  {15, 0, fit, 13, base.Uint16},
		14:  {16, 0, fit, 14, base.Uint16},
		15:  {17, 0, fit, 15, base.Uint8},
		16:  {18, 0, fit, 16, base.Uint8},
		17:  {19, 0, fit, 17, base.Uint8},
		18:  {20, 0, fit, 18, base.Uint8},
		19:  {21, 0, fit, 19, base.Uint16},
		20:  {22, 0, fit, 20, base.Uint16},
		21:  {23, 0, fit, 21, base.Uint16},
		22:  {24, 0, fit, 22, base.Uint16},
		23:  {25, 0, fit, 23, base.Enum},
		24:  {26, 0, fit, 24, base.Uint8},
		25:  {27, 0, lat, 25, base.Sint32},
		26:  {28, 0, lng, 26, base.Sint32},
		27:  {29, 0, lat, 27, base.Sint32},
		28:  {30, 0, lng, 28, base.Sint32},
		29:  {31, 0, fit, 29, base.String},
		30:  {32, 0, fit, 30, base.Uint16},
		31:  {33, 0, fit, 31, base.Uint16},
		32:  {34, 0, fit, 32, base.Enum},
		33:  {35, 0, fit, 33, base.Uint32},
		34:  {36, 0, fit, 34, base.Uint16},
		35:  {37, 0, fit, 35, base.Uint16},
		36:  {38, 0, fit, 36, base.Uint8},
		37:  {39, 0, fit, 37, base.Sint16},
		38:  {40, 0, fit, 38, base.Sint16},
		39:  {41, 0, fit, 39, base.Sint16},
		40:  {42, 0, fit, 40, base.Sint16},
		41:  {43, 0, fit, 41, base.Sint16},
		42:  {44, 0, fit, 42, base.Sint8},
		43:  {45, 0, fit, 43, base.Sint8},
		44:  {46, 0, fit, 44, base.Uint32},
		45:  {47, 0, fit, 45, base.Sint16},
		46:  {48, 0, fit, 46, base.Sint16},
		47:  {49, 0, fit, 47, base.Sint16},
		48:  {50, 0, fit, 48, base.Sint16},
		49:  {51, 255, fit, 49, base.Uint32},
		50:  {52, 255, fit, 50, base.Uint32},
		51:  {53, 255, fit, 51, base.Uint32},
		52:  {54, 255, fit, 52, base.Uint32},
		53:  {55, 0, fit, 53, base.Uint16},
		54:  {56, 0, fit, 54, base.Uint16},
		55:  {57, 0, fit, 55, base.Uint8},
		56:  {58, 0, fit, 56, base.Uint32},
		57:  {59, 0, fit, 57, base.Uint16},
		58:  {60, 0, fit, 58, base.Enum},
		59:  {61, 0, fit, 59, base.Uint8},
		60:  {62, 0, fit, 60, base.Uint8},
		61:  {63, 0, fit, 61, base.Uint8},
		62:  {64, 0, fit, 62, base.Uint8},
		63:  {65, 0, fit, 63, base.Uint8},
		64:  {66, 0, fit, 64, base.Enum},
		65:  {67, 0, fit, 65, base.String},
		66:  {68, 0, fit, 66, base.Uint8},
		67:  {69, 0, fit, 67, base.Uint8},
		68:  {70, 0, fit, 68, base.Uint8},
		69:  {71, 0, fit, 69, base.Uint16},
		70:  {72, 0, fit, 70, base.Uint16},
	},

	MesgNumSegmentFile: {
		254: {0, 0, fit, 254, base.Uint16},
		1:   {1, 0, fit, 1, base.String},
		3:   {2, 0, fit, 3, base.Enum},
		4:   {3, 0, fit, 4, base.Uint32},
		7:   {4, 255, fit, 7, base.Enum},
		8:   {5, 255, fit, 8, base.Uint32},
		9:   {6, 255, fit, 9, base.Uint32},
	},

	MesgNumWorkout: {
		4: {0, 0, fit, 4, base.Enum},
		5: {1, 0, fit, 5, base.Uint32z},
		6: {2, 0, fit, 6, base.Uint16},
		8: {3, 0, fit, 8, base.String},
	},

	MesgNumWorkoutStep: {
		254: {0, 0, fit, 254, base.Uint16},
		0:   {1, 0, fit, 0, base.String},
		1:   {2, 0, fit, 1, base.Enum},
		2:   {3, 0, fit, 2, base.Uint32},
		3:   {4, 0, fit, 3, base.Enum},
		4:   {5, 0, fit, 4, base.Uint32},
		5:   {6, 0, fit, 5, base.Uint32},
		6:   {7, 0, fit, 6, base.Uint32},
		7:   {8, 0, fit, 7, base.Enum},
	},

	MesgNumSchedule: {
		0: {0, 0, fit, 0, base.Uint16},
		1: {1, 0, fit, 1, base.Uint16},
		2: {2, 0, fit, 2, base.Uint32z},
		3: {3, 0, timeutc, 3, base.Uint32},
		4: {4, 0, fit, 4, base.Enum},
		5: {5, 0, fit, 5, base.Enum},
		6: {6, 0, timelocal, 6, base.Uint32},
	},

	MesgNumTotals: {
		254: {0, 0, fit, 254, base.Uint16},
		253: {1, 0, timeutc, 253, base.Uint32},
		0:   {2, 0, fit, 0, base.Uint32},
		1:   {3, 0, fit, 1, base.Uint32},
		2:   {4, 0, fit, 2, base.Uint32},
		3:   {5, 0, fit, 3, base.Enum},
		4:   {6, 0, fit, 4, base.Uint32},
		5:   {7, 0, fit, 5, base.Uint16},
		6:   {8, 0, fit, 6, base.Uint32},
	},

	MesgNumWeightScale: {
		253: {0, 0, timeutc, 253, base.Uint32},
		0:   {1, 0, fit, 0, base.Uint16},
		1:   {2, 0, fit, 1, base.Uint16},
		2:   {3, 0, fit, 2, base.Uint16},
		3:   {4, 0, fit, 3, base.Uint16},
		4:   {5, 0, fit, 4, base.Uint16},
		5:   {6, 0, fit, 5, base.Uint16},
		7:   {7, 0, fit, 7, base.Uint16},
		8:   {8, 0, fit, 8, base.Uint8},
		9:   {9, 0, fit, 9, base.Uint16},
		10:  {10, 0, fit, 10, base.Uint8},
		11:  {11, 0, fit, 11, base.Uint8},
		12:  {12, 0, fit, 12, base.Uint16},
	},

	MesgNumBloodPressure: {
		253: {0, 0, timeutc, 253, base.Uint32},
		0:   {1, 0, fit, 0, base.Uint16},
		1:   {2, 0, fit, 1, base.Uint16},
		2:   {3, 0, fit, 2, base.Uint16},
		3:   {4, 0, fit, 3, base.Uint16},
		4:   {5, 0, fit, 4, base.Uint16},
		5:   {6, 0, fit, 5, base.Uint16},
		6:   {7, 0, fit, 6, base.Uint8},
		7:   {8, 0, fit, 7, base.Enum},
		8:   {9, 0, fit, 8, base.Enum},
		9:   {10, 0, fit, 9, base.Uint16},
	},

	MesgNumMonitoringInfo: {
		253: {0, 0, timeutc, 253, base.Uint32},
		0:   {1, 0, timelocal, 0, base.Uint32},
	},

	MesgNumMonitoring: {
		253: {0, 0, timeutc, 253, base.Uint32},
		0:   {1, 0, fit, 0, base.Uint8},
		1:   {2, 0, fit, 1, base.Uint16},
		2:   {3, 0, fit, 2, base.Uint32},
		3:   {4, 0, fit, 3, base.Uint32},
		4:   {5, 0, fit, 4, base.Uint32},
		5:   {6, 0, fit, 5, base.Enum},
		6:   {7, 0, fit, 6, base.Enum},
		8:   {8, 0, fit, 8, base.Uint16},
		9:   {9, 0, fit, 9, base.Uint16},
		10:  {10, 0, fit, 10, base.Uint16},
		11:  {11, 0, timelocal, 11, base.Uint32},
	},

	MesgNumMemoGlob: {},
}

func getField(gmn MesgNum, fdn byte) (*field, bool) {
	if int(gmn) >= len(_fields) {
		return nil, false
	}
	f := _fields[gmn][fdn]
	if f == nil {
		return nil, false
	}
	return f, true
}

var msgsAllInvalid = [...]reflect.Value{
	MesgNumFileId: reflect.ValueOf(&FileIdMsg{
		0xFF,
		0xFFFF,
		0xFFFF,
		0xFFFFFFFF,
		timeBase,
		0xFFFF,
		"",
	}),
	MesgNumFileCreator: reflect.ValueOf(&FileCreatorMsg{
		0xFFFF,
		0xFF,
	}),
	MesgNumTimestampCorrelation: reflect.ValueOf(&TimestampCorrelationMsg{}),
	MesgNumSoftware: reflect.ValueOf(&SoftwareMsg{
		0xFFFF,
		0xFFFF,
		"",
	}),
	MesgNumSlaveDevice: reflect.ValueOf(&SlaveDeviceMsg{
		0xFFFF,
		0xFFFF,
	}),
	MesgNumCapabilities: reflect.ValueOf(&CapabilitiesMsg{
		nil,
		nil,
		0x00000000,
		0x00000000,
	}),
	MesgNumFileCapabilities: reflect.ValueOf(&FileCapabilitiesMsg{
		0xFFFF,
		0xFF,
		0x00,
		"",
		0xFFFF,
		0xFFFFFFFF,
	}),
	MesgNumMesgCapabilities: reflect.ValueOf(&MesgCapabilitiesMsg{
		0xFFFF,
		0xFF,
		0xFFFF,
		0xFF,
		0xFFFF,
	}),
	MesgNumFieldCapabilities: reflect.ValueOf(&FieldCapabilitiesMsg{
		0xFFFF,
		0xFF,
		0xFFFF,
		0xFF,
		0xFFFF,
	}),
	MesgNumDeviceSettings: reflect.ValueOf(&DeviceSettingsMsg{
		0xFF,
		0xFFFFFFFF,
		nil,
	}),
	MesgNumUserProfile: reflect.ValueOf(&UserProfileMsg{
		0xFFFF,
		"",
		0xFF,
		0xFF,
		0xFF,
		0xFFFF,
		0xFF,
		0xFF,
		0xFF,
		0xFF,
		0xFF,
		0xFF,
		0xFF,
		0xFF,
		0xFF,
		0xFF,
		0xFF,
		0xFF,
		0xFF,
		0xFF,
		0xFFFF,
		nil,
		0xFF,
	}),
	MesgNumHrmProfile: reflect.ValueOf(&HrmProfileMsg{
		0xFFFF,
		0xFF,
		0xFFFF,
		0xFF,
		0xFF,
	}),
	MesgNumSdmProfile: reflect.ValueOf(&SdmProfileMsg{
		0xFFFF,
		0xFF,
		0xFFFF,
		0xFFFF,
		0xFFFFFFFF,
		0xFF,
		0xFF,
		0xFF,
	}),
	MesgNumBikeProfile: reflect.ValueOf(&BikeProfileMsg{
		0xFFFF,
		"",
		0xFF,
		0xFF,
		0xFFFFFFFF,
		0xFFFF,
		0xFFFF,
		0xFFFF,
		0xFFFF,
		0xFFFF,
		0xFFFF,
		0xFFFF,
		0xFFFF,
		0xFF,
		0xFF,
		0xFF,
		0xFF,
		0xFF,
		0xFF,
		0xFF,
		0xFF,
		0xFF,
		0xFF,
		0xFF,
		0xFF,
		0xFF,
		0xFF,
		0xFF,
		nil,
		0xFF,
		nil,
		0xFF,
	}),
	MesgNumZonesTarget: reflect.ValueOf(&ZonesTargetMsg{
		0xFF,
		0xFF,
		0xFFFF,
		0xFF,
		0xFF,
	}),
	MesgNumSport: reflect.ValueOf(&SportMsg{
		0xFF,
		0xFF,
		"",
	}),
	MesgNumHrZone: reflect.ValueOf(&HrZoneMsg{
		0xFFFF,
		0xFF,
		"",
	}),
	MesgNumSpeedZone: reflect.ValueOf(&SpeedZoneMsg{
		0xFFFF,
		0xFFFF,
		"",
	}),
	MesgNumCadenceZone: reflect.ValueOf(&CadenceZoneMsg{
		0xFFFF,
		0xFF,
		"",
	}),
	MesgNumPowerZone: reflect.ValueOf(&PowerZoneMsg{
		0xFFFF,
		0xFFFF,
		"",
	}),
	MesgNumMetZone: reflect.ValueOf(&MetZoneMsg{
		0xFFFF,
		0xFF,
		0xFFFF,
		0xFF,
	}),
	MesgNumGoal: reflect.ValueOf(&GoalMsg{
		0xFFFF,
		0xFF,
		0xFF,
		timeBase,
		timeBase,
		0xFF,
		0xFFFFFFFF,
		0xFF,
		0xFFFFFFFF,
		0xFF,
		0xFFFF,
		0xFF,
	}),
	MesgNumActivity: reflect.ValueOf(&ActivityMsg{
		timeBase,
		0xFFFFFFFF,
		0xFFFF,
		0xFF,
		0xFF,
		0xFF,
		timeBase,
		0xFF,
	}),
	MesgNumSession: reflect.ValueOf(&SessionMsg{
		0xFFFF,
		timeBase,
		0xFF,
		0xFF,
		timeBase,
		NewLatitudeInvalid(),
		NewLongitudeInvalid(),
		0xFF,
		0xFF,
		0xFFFFFFFF,
		0xFFFFFFFF,
		0xFFFFFFFF,
		0xFFFFFFFF,
		0xFFFF,
		0xFFFF,
		0xFFFF,
		0xFFFF,
		0xFF,
		0xFF,
		0xFF,
		0xFF,
		0xFFFF,
		0xFFFF,
		0xFFFF,
		0xFFFF,
		0xFF,
		0xFFFF,
		0xFFFF,
		0xFF,
		0xFF,
		NewLatitudeInvalid(),
		NewLongitudeInvalid(),
		NewLatitudeInvalid(),
		NewLongitudeInvalid(),
		0xFFFF,
		0xFFFF,
		0xFFFF,
		0xFFFF,
		0xFFFFFFFF,
		0xFFFF,
		0xFF,
		0xFFFF,
		0xFFFF,
		0xFF,
		0xFFFF,
		0xFFFFFFFF,
		0xFFFF,
		0xFFFF,
		0xFF,
		0x7FFF,
		0x7FFF,
		0x7FFF,
		0x7FFF,
		0x7FFF,
		0x7F,
		0x7F,
		0xFFFFFFFF,
		0x7FFF,
		0x7FFF,
		0x7FFF,
		0x7FFF,
		0xFF,
		nil,
		nil,
		nil,
		nil,
		0xFFFFFFFF,
		0xFFFF,
		0xFFFF,
		0xFFFF,
		0xFFFF,
		"",
		nil,
		nil,
		0xFFFF,
		0xFFFF,
		0xFFFF,
		0xFFFF,
		0xFFFF,
		0xFF,
		0xFF,
		0xFF,
		0xFF,
		0xFFFFFFFF,
		0xFFFFFFFF,
		0xFFFFFFFF,
		0xFFFFFFFF,
		0xFFFFFFFF,
	}),
	MesgNumLap: reflect.ValueOf(&LapMsg{
		0xFFFF,
		timeBase,
		0xFF,
		0xFF,
		timeBase,
		NewLatitudeInvalid(),
		NewLongitudeInvalid(),
		NewLatitudeInvalid(),
		NewLongitudeInvalid(),
		0xFFFFFFFF,
		0xFFFFFFFF,
		0xFFFFFFFF,
		0xFFFFFFFF,
		0xFFFF,
		0xFFFF,
		0xFFFF,
		0xFFFF,
		0xFF,
		0xFF,
		0xFF,
		0xFF,
		0xFFFF,
		0xFFFF,
		0xFFFF,
		0xFFFF,
		0xFF,
		0xFF,
		0xFF,
		0xFF,
		0xFFFF,
		0xFFFF,
		0xFFFF,
		0xFFFF,
		0xFFFF,
		0xFF,
		0xFF,
		0xFFFF,
		0xFFFFFFFF,
		0xFFFF,
		0xFFFF,
		0xFF,
		0x7FFF,
		0x7FFF,
		0x7FFF,
		0x7FFF,
		0x7FFF,
		0x7F,
		0x7F,
		0xFFFFFFFF,
		0x7FFF,
		0x7FFF,
		0x7FFF,
		0x7FFF,
		nil,
		nil,
		nil,
		nil,
		0xFFFF,
		0xFFFF,
		0xFF,
		0xFFFF,
		0xFFFF,
		nil,
		nil,
		0xFFFF,
		0xFFFF,
		0xFFFF,
		0xFF,
		0xFF,
		0xFF,
		0xFFFF,
		nil,
		nil,
		nil,
		nil,
		nil,
		nil,
		0xFFFFFFFF,
		0xFFFFFFFF,
		0xFFFFFFFF,
		0xFFFFFFFF,
		0xFFFFFFFF,
	}),
	MesgNumLength: reflect.ValueOf(&LengthMsg{
		0xFFFF,
		timeBase,
		0xFF,
		0xFF,
		timeBase,
		0xFFFFFFFF,
		0xFFFFFFFF,
		0xFFFF,
		0xFFFF,
		0xFF,
		0xFF,
		0xFF,
		0xFFFF,
		0xFF,
		0xFFFF,
		0xFFFF,
		nil,
		nil,
	}),
	MesgNumRecord: reflect.ValueOf(&RecordMsg{
		timeBase,
		NewLatitudeInvalid(),
		NewLongitudeInvalid(),
		0xFFFF,
		0xFF,
		0xFF,
		0xFFFFFFFF,
		0xFFFF,
		0xFFFF,
		nil,
		0x7FFF,
		0xFF,
		0x7FFFFFFF,
		0xFF,
		0x7F,
		nil,
		0xFF,
		0xFFFFFFFF,
		0xFFFF,
		0xFFFFFFFF,
		0xFF,
		0xFF,
		0x7FFF,
		0xFFFF,
		0xFFFF,
		0xFFFF,
		0xFFFF,
		0xFF,
		0xFF,
		0xFF,
		0xFF,
		0xFF,
		0xFF,
		0xFF,
		0xFF,
		0xFF,
		0xFFFF,
		0xFFFF,
		0xFF,
		0xFFFF,
		0xFFFF,
		0xFFFF,
		0xFFFF,
		0xFFFF,
		0xFFFF,
		0xFF,
		0xFFFFFFFF,
		0xFFFFFFFF,
	}),
	MesgNumEvent: reflect.ValueOf(&EventMsg{
		timeBase,
		0xFF,
		0xFF,
		0xFFFF,
		0xFFFFFFFF,
		0xFF,
		0xFFFF,
		0xFFFF,
		0xFF,
		0xFF,
		0xFF,
		0xFF,
	}),
	MesgNumDeviceInfo: reflect.ValueOf(&DeviceInfoMsg{
		timeBase,
		0xFF,
		0xFF,
		0xFFFF,
		0xFFFFFFFF,
		0xFFFF,
		0xFFFF,
		0xFF,
		0xFFFFFFFF,
		0xFFFF,
		0xFF,
		0xFF,
		"",
		0xFF,
		0xFFFF,
		0xFF,
		0xFF,
		"",
	}),
	MesgNumTrainingFile: reflect.ValueOf(&TrainingFileMsg{
		timeBase,
		0xFF,
		0xFFFF,
		0xFFFF,
		0xFFFFFFFF,
		timeBase,
	}),
	MesgNumHrv: reflect.ValueOf(&HrvMsg{
		nil,
	}),
	MesgNumCameraEvent:             reflect.ValueOf(&CameraEventMsg{}),
	MesgNumGyroscopeData:           reflect.ValueOf(&GyroscopeDataMsg{}),
	MesgNumAccelerometerData:       reflect.ValueOf(&AccelerometerDataMsg{}),
	MesgNumThreeDSensorCalibration: reflect.ValueOf(&ThreeDSensorCalibrationMsg{}),
	MesgNumVideoFrame:              reflect.ValueOf(&VideoFrameMsg{}),
	MesgNumObdiiData:               reflect.ValueOf(&ObdiiDataMsg{}),
	MesgNumNmeaSentence: reflect.ValueOf(&NmeaSentenceMsg{
		timeBase,
		0xFFFF,
		"",
	}),
	MesgNumAviationAttitude: reflect.ValueOf(&AviationAttitudeMsg{
		timeBase,
		0xFFFF,
		nil,
		nil,
		nil,
		nil,
		nil,
		nil,
		nil,
		nil,
		nil,
		nil,
	}),
	MesgNumVideo: reflect.ValueOf(&VideoMsg{}),
	MesgNumVideoTitle: reflect.ValueOf(&VideoTitleMsg{
		0xFFFF,
		0xFFFF,
		"",
	}),
	MesgNumVideoDescription: reflect.ValueOf(&VideoDescriptionMsg{
		0xFFFF,
		0xFFFF,
		"",
	}),
	MesgNumVideoClip: reflect.ValueOf(&VideoClipMsg{}),
	MesgNumCourse: reflect.ValueOf(&CourseMsg{
		0xFF,
		"",
		0x00000000,
	}),
	MesgNumCoursePoint: reflect.ValueOf(&CoursePointMsg{
		0xFFFF,
		timeBase,
		NewLatitudeInvalid(),
		NewLongitudeInvalid(),
		0xFFFFFFFF,
		0xFF,
		"",
		0xFF,
	}),
	MesgNumSegmentId: reflect.ValueOf(&SegmentIdMsg{
		"",
		"",
		0xFF,
		0xFF,
		0xFFFFFFFF,
		0xFFFFFFFF,
		0xFF,
		0xFF,
		0xFF,
	}),
	MesgNumSegmentLeaderboardEntry: reflect.ValueOf(&SegmentLeaderboardEntryMsg{
		0xFFFF,
		"",
		0xFF,
		0xFFFFFFFF,
		0xFFFFFFFF,
		0xFFFFFFFF,
	}),
	MesgNumSegmentPoint: reflect.ValueOf(&SegmentPointMsg{
		0xFFFF,
		NewLatitudeInvalid(),
		NewLongitudeInvalid(),
		0xFFFFFFFF,
		0xFFFF,
		nil,
	}),
	MesgNumSegmentLap: reflect.ValueOf(&SegmentLapMsg{
		0xFFFF,
		timeBase,
		0xFF,
		0xFF,
		timeBase,
		NewLatitudeInvalid(),
		NewLongitudeInvalid(),
		NewLatitudeInvalid(),
		NewLongitudeInvalid(),
		0xFFFFFFFF,
		0xFFFFFFFF,
		0xFFFFFFFF,
		0xFFFFFFFF,
		0xFFFF,
		0xFFFF,
		0xFFFF,
		0xFFFF,
		0xFF,
		0xFF,
		0xFF,
		0xFF,
		0xFFFF,
		0xFFFF,
		0xFFFF,
		0xFFFF,
		0xFF,
		0xFF,
		NewLatitudeInvalid(),
		NewLongitudeInvalid(),
		NewLatitudeInvalid(),
		NewLongitudeInvalid(),
		"",
		0xFFFF,
		0xFFFF,
		0xFF,
		0xFFFFFFFF,
		0xFFFF,
		0xFFFF,
		0xFF,
		0x7FFF,
		0x7FFF,
		0x7FFF,
		0x7FFF,
		0x7FFF,
		0x7F,
		0x7F,
		0xFFFFFFFF,
		0x7FFF,
		0x7FFF,
		0x7FFF,
		0x7FFF,
		nil,
		nil,
		nil,
		nil,
		0xFFFF,
		0xFFFF,
		0xFF,
		0xFFFFFFFF,
		0xFFFF,
		0xFF,
		0xFF,
		0xFF,
		0xFF,
		0xFF,
		0xFF,
		0xFF,
		"",
		0xFF,
		0xFF,
		0xFF,
		0xFFFF,
		0xFFFF,
	}),
	MesgNumSegmentFile: reflect.ValueOf(&SegmentFileMsg{
		0xFFFF,
		"",
		0xFF,
		0xFFFFFFFF,
		nil,
		nil,
		nil,
	}),
	MesgNumWorkout: reflect.ValueOf(&WorkoutMsg{
		0xFF,
		0x00000000,
		0xFFFF,
		"",
	}),
	MesgNumWorkoutStep: reflect.ValueOf(&WorkoutStepMsg{
		0xFFFF,
		"",
		0xFF,
		0xFFFFFFFF,
		0xFF,
		0xFFFFFFFF,
		0xFFFFFFFF,
		0xFFFFFFFF,
		0xFF,
	}),
	MesgNumSchedule: reflect.ValueOf(&ScheduleMsg{
		0xFFFF,
		0xFFFF,
		0xFFFFFFFF,
		timeBase,
		0xFF,
		0xFF,
		timeBase,
	}),
	MesgNumTotals: reflect.ValueOf(&TotalsMsg{
		0xFFFF,
		timeBase,
		0xFFFFFFFF,
		0xFFFFFFFF,
		0xFFFFFFFF,
		0xFF,
		0xFFFFFFFF,
		0xFFFF,
		0xFFFFFFFF,
	}),
	MesgNumWeightScale: reflect.ValueOf(&WeightScaleMsg{
		timeBase,
		0xFFFF,
		0xFFFF,
		0xFFFF,
		0xFFFF,
		0xFFFF,
		0xFFFF,
		0xFFFF,
		0xFF,
		0xFFFF,
		0xFF,
		0xFF,
		0xFFFF,
	}),
	MesgNumBloodPressure: reflect.ValueOf(&BloodPressureMsg{
		timeBase,
		0xFFFF,
		0xFFFF,
		0xFFFF,
		0xFFFF,
		0xFFFF,
		0xFFFF,
		0xFF,
		0xFF,
		0xFF,
		0xFFFF,
	}),
	MesgNumMonitoringInfo: reflect.ValueOf(&MonitoringInfoMsg{
		timeBase,
		timeBase,
	}),
	MesgNumMonitoring: reflect.ValueOf(&MonitoringMsg{
		timeBase,
		0xFF,
		0xFFFF,
		0xFFFFFFFF,
		0xFFFFFFFF,
		0xFFFFFFFF,
		0xFF,
		0xFF,
		0xFFFF,
		0xFFFF,
		0xFFFF,
		timeBase,
	}),
	MesgNumMemoGlob: reflect.ValueOf(&MemoGlobMsg{}),
}

func getMesgAllInvalid(mn MesgNum) reflect.Value {
	return reflect.ValueOf(msgsAllInvalid[mn].Interface()).Elem()
}
// STRINGER TYPE INPUT
ActivityClass,ActivityLevel,ActivityMode,ActivitySubtype,ActivityType,AntNetwork,AntplusDeviceType,AttitudeStage,AttitudeValidity,AutolapTrigger,BatteryStatus,BodyLocation,BpStatus,CameraEventType,CameraOrientationType,Checksum,CommTimeoutType,ConnectivityCapabilities,CourseCapabilities,CoursePoint,DeviceIndex,DisplayHeart,DisplayMeasure,DisplayPosition,DisplayPower,Event,EventType,File,FileFlags,FitnessEquipmentState,GarminProduct,Gender,Goal,GoalRecurrence,HrType,HrZoneCalc,Intensity,Language,LapTrigger,LeftRightBalance,LeftRightBalance100,LengthType,Manufacturer,MesgCount,MesgNum,MessageIndex,PowerPhaseType,PwrZoneCalc,RiderPositionType,Schedule,SegmentDeleteStatus,SegmentLapStatus,SegmentLeaderboardType,SegmentSelectionType,SensorType,SessionTrigger,SourceType,Sport,SportBits0,SportBits1,SportBits2,SportBits3,SportBits4,SportBits5,SportEvent,StrokeType,SubSport,SwimStroke,TimeZone,TimerTrigger,UserLocalId,Weight,WktStepDuration,WktStepTarget,WorkoutCapabilities,WorkoutHr,WorkoutPower
// MESSAGE NUMS WITHOUT MESSAGE
Pad
GpsMetadata
